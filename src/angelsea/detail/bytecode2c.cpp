// SPDX-License-Identifier: BSD-2-Clause

#include "angelsea/config.hpp"
#include "angelsea/detail/runtime.hpp"
#include "as_objecttype.h"
#include <algorithm>
#include <angelscript.h>
#include <angelsea/detail/bytecode2c.hpp>
#include <angelsea/detail/bytecodedisasm.hpp>
#include <angelsea/detail/bytecodeinstruction.hpp>
#include <angelsea/detail/bytecodetools.hpp>
#include <angelsea/detail/debug.hpp>
#include <angelsea/detail/log.hpp>
#include <angelsea/detail/runtimeheader.hpp>
#include <angelsea/detail/stringutil.hpp>
#include <angelsea/detail/util.hpp>
#include <as_callfunc.h>
#include <as_config.h>
#include <as_context.h>
#include <as_property.h>
#include <as_scriptengine.h>
#include <as_texts.h>
#include <bit>
#include <fmt/format.h>
#include <fmt/ranges.h>
#include <variant>

#define DIRECT_VALUE_IF_POSSIBLE(var) (m_config->c.emit_hardcoded_vm_offsets ? fmt::to_string(var) : #var)

namespace angelsea::detail {

// TODO: fix indent level for all of those that use this...

BytecodeToC::BytecodeToC(const JitConfig& config, asIScriptEngine& engine, std::string c_symbol_prefix) :
    m_config(&config),
    m_script_engine(static_cast<asCScriptEngine*>(&engine)),
    m_c_symbol_prefix(std::move(c_symbol_prefix)),
    m_module_idx(-1) {}

void BytecodeToC::prepare_new_context() {
	++m_module_idx;
	m_module_state = {};
}

TranspiledCode BytecodeToC::finalize_context() {
	TranspiledCode ret;
	ret.code_blocks = std::move(m_module_state.code_blocks);
	if (m_config->c.copyright_header) {
		ret.source_bits.emplace_back(angelsea_c_header_copyright);
	}
	ret.source_bits.emplace_back(angelsea_c_header);
	if (!m_config->c.emit_hardcoded_vm_offsets) {
		angelsea_assert(false && "non-hardcoded VM offsets needs fixing...");
	}
	if (m_config->c.human_readable) {
		ret.source_bits.emplace_back("\n/* start of code generated by angelsea bytecode2c */\n");
	}
	ret.source_bits.emplace_back(ret.code_blocks.forward_declarations.c_str());
	ret.source_bits.emplace_back(ret.code_blocks.function_code.c_str());
	return ret;
}

void BytecodeToC::translate_function(std::string_view internal_module_name, asIScriptFunction& fn) {
	m_module_state.fn_name = create_new_entry_point_name(fn);

	if (m_on_map_function_callback) {
		m_on_map_function_callback(fn, m_module_state.fn_name);
	}

	if (m_config->c.human_readable) {
		const char* section_name;
		int         row, col;
		fn.GetDeclaredAt(&section_name, &row, &col);
		emit(
		    "/* {}:{}:{}: {} */\n",
		    section_name != nullptr ? section_name : "<anon>",
		    row,
		    col,
		    fn.GetDeclaration(true, true, true)
		);
	}

	m_module_state.fn_bytecode_ptr = fmt::format("{}_bc", m_module_state.fn_name);
	emit("extern asDWORD {}[];\n", m_module_state.fn_bytecode_ptr);
	if (m_on_map_extern_callback) {
		m_on_map_extern_callback(
		    m_module_state.fn_bytecode_ptr.c_str(),
		    ExternBytecodeDefinition{.fn = &fn},
		    fn.GetByteCode()
		);
	}

	// JIT entry signature is `void(asSVMRegisters *regs, asPWORD jitArg)`
	emit("void {name}(asSVMRegisters *_regs, asPWORD entryLabel) {{\n", fmt::arg("name", m_module_state.fn_name));

	// HACK: which we would prefer not to do; but accessing value is
	// going to be pain with strict aliasing either way
	emit(
	    "\tasea_vm_registers *regs = (asea_vm_registers *)_regs;\n"
	    "\tasDWORD *const base_pc = {BASE_PC};\n"
	    "\tasea_var* sp = regs->sp;\n"
	    "\tasea_var *const fp = regs->fp;\n"
	    "\tasQWORD value_reg = regs->value;\n"
	    "\tint cond_reg;\n",
	    fmt::arg("BASE_PC", m_module_state.fn_bytecode_ptr)
	);

	FnState state{
	    .fn                       = &fn,   // TODO: move to module state
	    .ins                      = {},    // populated before translate_instruction
	    .has_any_late_jit_entries = true,  // populated by has_any_late_jit_entries
	    .switch_map               = {},    // populated by discover_switch_map
	    .branch_targets           = {},    // populated by discover_branch_targets
	    .stack_push_infos         = {},    // populated by discover_function_call_pushes
	    .fn_to_stack_push         = {},    // ^
	    .overriden_instructions   = {},    // populated by several passes, but primarily discover_peephole
	    .emitted_symbols          = {},    // populated by whatever emits extern declarations
	    .has_direct_generic_call  = false, // populated by discover_function_calls
	    .error_handlers_mask      = 0,     // populated by any translate_instruction
	};

	discover_switch_map(state);
	configure_jit_entries(state);
	discover_branch_targets(state);
	discover_function_calls(state);
	if (m_config->experimental_stack_elision) {
		discover_function_call_pushes(state);
	}
	discover_peephole(state);

	if (m_config->experimental_direct_generic_call /* && state.has_direct_generic_call*/) {
		// FIXME: has_direct_generic_call is broken with refcpyv
		emit(
		    "\tasea_generic g;\n"
		    "\tg._vtable = &asea_generic_vtable;\n"
		    "\tg.engine = *(asCScriptEngine**)((char*)regs->ctx + {OFF_ENGINE});\n",
		    fmt::arg("OFF_ENGINE", DIRECT_VALUE_IF_POSSIBLE(asea_offset_ctx_engine))
		);
	}

	// check generated code with for an idea of the generated code structure; also see the Q&A in readme that briefly
	// explains how the translation process occurs.

	if (m_config->debug.trace_functions) {
		const char* section;
		int         row, col;
		fn.GetDeclaredAt(&section, &row, &col);
		emit(
		    "\tasea_debug_message(_regs, \"TRACE FUNCTION: module "
		    "{}: {}:{}:{}: {}; JitEntry follows:\");\n"
		    "\tasea_debug_int(_regs, entryLabel);\n\n",
		    internal_module_name,
		    escape_c_literal(section != nullptr ? section : "<anon>"),
		    row,
		    col,
		    escape_c_literal(fn.GetDeclaration(true, true, true))
		);
	}

	emit_entry_dispatch(state);

	for (InsRef ins : get_bytecode(fn)) {
		state.ins = ins;
		translate_instruction(state);
	}

	emit_error_handlers(state);

	emit("}}\n");
}

std::string BytecodeToC::create_new_entry_point_name([[maybe_unused]] asIScriptFunction& fn) {
	angelsea_assert(fn.GetId() != 0 && "Did not expect a delegate function");

	// TODO: unified global mapping, but it's not so trivial if also having to track destructions -- pretty sure GetId()
	// can be reused in AS

	const auto str = fmt::format("{}_mod{}_fn{}", m_c_symbol_prefix, m_module_idx, m_module_state.fn_idx);
	++m_module_state.fn_idx;
	return str;
}

void BytecodeToC::configure_jit_entries(FnState& state) {
	asPWORD jit_entry_id = 1;

	// answers: is the sequence of instructions since the last jit entry likely supported?
	bool is_trace_supported = true;

	auto bytecode = get_bytecode(*state.fn);
	for (auto it = bytecode.begin(), prev = it; it != bytecode.end(); prev = it, ++it) {
		InsRef ins = *it;

		if (ins.opcode() == asBC_JitEntry) {
			if (it == bytecode.begin() || !is_trace_supported) {
				ins.pword0() = jit_entry_id;
				++jit_entry_id;
			} else {
				// neutralize jit entry point
				ins.pword0() = 0;
			}

			is_trace_supported = true;
		}

		if (!is_trace_supported) {
			continue;
		}

		if (is_instruction_blacklisted(ins.opcode())) {
			is_trace_supported = false;
			continue;
		}

		// consider skipping some JitEntry we believe the VM should never be hitting. this is useful to avoid
		// pessimizing optimizations, so that the optimizer can merge subsequent basic blocks.
		switch (ins.opcode()) {
		case asBC_SUSPEND: // TODO: falls back as of writing, remove when fixed
			is_trace_supported = m_config->hack_ignore_suspend;
			break;

			// assume script calls can always fallback
		case asBC_CALL:
		case asBC_CALLINTF:
		// TODO: those only have partial support and can fallback to the vm
		// TODO: asBC_ALLOC should only be considered a possible fallback for script entities even after they are
		// implemented because we yield back to the VM just like asBC_CALL in that case anyway
		case asBC_ALLOC:
		case asBC_FREE:
		// TODO: all of those are not implemented as of writing, remove when fixed
		case asBC_SwapPtr:
		case asBC_LdGRdR4:
		case asBC_CALLBND:
		case asBC_CallPtr:
		case asBC_ChkRefS:
		case asBC_ClrHi:
		case asBC_FuncPtr:
		case asBC_AllocMem:
		case asBC_SetListSize:
		case asBC_PshListElmnt:
		case asBC_SetListType:
		case asBC_POWi:
		case asBC_POWu:
		case asBC_POWf:
		case asBC_POWd:
		case asBC_POWdi:
		case asBC_POWi64:
		case asBC_POWu64:       is_trace_supported = false; break;

		// only skip if it's a known instruction as of writing
		default:                is_trace_supported = ins.opcode() <= asBC_Thiscall1;
		}

		// NOTE: this doesn't seem to need to care about branch targets: we normally support basically all branching
		// instructions, and AS should always be emitting a jit entry at _some point_ before

		// NOTE: we shouldn't remove the jitentry after an asBC_CALL because it's not unlikely the callee is going
		// to want to return execution to the VM -- in that case, we always immediately return to the VM
	}

	state.has_any_late_jit_entries = jit_entry_id > 2; // because of the increment
}

void BytecodeToC::discover_switch_map(FnState& state) {
	// discover mappings from the offset of every asBC_JMPP instruction and the branch targets
	std::vector<std::size_t>* current_mapping = nullptr;

	for (InsRef ins : get_bytecode(*state.fn)) {
		if (ins.opcode() == asBC_JMPP) {
			current_mapping = &state.switch_map[ins.offset]; // create
		} else if (ins.opcode() == asBC_JMP) {
			if (current_mapping != nullptr) {
				current_mapping->emplace_back(ins.offset + ins.size() + ins.int0());

				// avoid emitting useless BBs that will just get destroyed anyway
				state.overriden_instructions.emplace(ins.offset, virtins::Nop{});
			}
		} else {
			current_mapping = nullptr;
		}
	}
}

void BytecodeToC::discover_branch_targets(FnState& state) {
	for (InsRef ins : get_bytecode(*state.fn)) {
		if (ins.opcode() == asBC_JitEntry && ins.pword0() != 0) {
			state.branch_targets.emplace(ins.offset);
		}

		if (auto jmp = bcins::try_as<bcins::Jump>(ins); jmp.has_value()) {
			state.branch_targets.emplace(jmp->target_offset());
		}
	}
}

void BytecodeToC::discover_function_calls(FnState& state) {
	for (InsRef ins : get_bytecode(*state.fn)) {
		if (auto call = bcins::try_as<bcins::CallSystemDirect>(ins); call.has_value()) {
			const auto& fn = call->function(*m_script_engine);
			if (fn.sysFuncIntf->callConv == ICC_GENERIC_FUNC || fn.sysFuncIntf->callConv == ICC_GENERIC_METHOD) {
				state.has_direct_generic_call = true;
			}
		}
	}
}

void BytecodeToC::discover_function_call_pushes(FnState& state) {
	auto bytecode_view = get_bytecode(*state.fn);

	std::vector<std::pair<std::size_t, StackPushInfo>> current_pushes;
	for (InsRef ins : bytecode_view) {
		// TODO: refactor the condition into a function?
		if (is_instruction_blacklisted(ins.opcode()) || ins.opcode() == m_config->debug.fallback_after_instruction
		    || state.branch_targets.contains(ins.offset)) {
			current_pushes.clear();
		} else if (auto call = bcins::try_as<bcins::CallSystemDirect>(ins); call.has_value()) {
			// const auto& fn = call->function(*m_script_engine);
			// printf("call @%d of fn %s:\n", int(ins.offset), fn.GetDeclaration());
			for (auto& [push_offset, push_info] : current_pushes) {
				state.stack_push_infos.emplace(push_offset, push_info);
				emit("\t{TYPE} push_tmp{ID};\n", fmt::arg("TYPE", push_info.type.c), fmt::arg("ID", push_offset));
				// printf(
				//     "^^^^ stack push %s\n",
				//     disassemble(*m_script_engine, *bytecode_view.begin().advanced_by_dwords(push_offset)).c_str()
				// );
			}

			// TODO: could be optimized/cleaned up here
			std::vector<std::size_t> pushes(current_pushes.size());
			for (std::size_t i = 0; i < current_pushes.size(); ++i) {
				pushes[i] = current_pushes[i].first;
			}
			state.fn_to_stack_push.emplace(ins.offset, std::move(pushes));

			current_pushes.clear();
		} else if (const auto push = bcins::try_as<bcins::StackPush>(ins); push.has_value()) {
			current_pushes.push_back({ins.offset, StackPushInfo{.type = visit_operand_type(push->value)}});
		} else {
			current_pushes.clear();
		}
	}
}

void BytecodeToC::discover_peephole(FnState& state) {
	auto bytecode = get_bytecode(*state.fn);
	for (auto it = bytecode.begin(); it != bytecode.end(); ++it) {
		auto next = std::next(it);
		if (next == bytecode.end()) {
			break;
		}

		if (is_instruction_blacklisted((*it).opcode()) || is_instruction_blacklisted((*next).opcode())) {
			continue;
		}

		{
			auto compare = bcins::try_as<bcins::Compare>(*it);
			auto jump    = bcins::try_as<bcins::Jump>(*next);
			if (compare.has_value() && jump.has_value() && jump->cond_expr.has_value()) {
				state.overriden_instructions.emplace((*it).offset, virtins::Nop{});
				state.overriden_instructions.emplace((*next).offset, virtins::FusedCompareJump{*compare, *jump});
			}
		}
	}
}

void BytecodeToC::emit_entry_dispatch(FnState& state) {
	if (!state.has_any_late_jit_entries) {
		if (m_config->c.human_readable) {
			emit("\t/* only one jit entry! not generating dispatch */\n");
		}
		return;
	}

	if (m_config->c.use_gnu_label_as_value) {
		emit(
		    "\tstatic const void *const entry[] = {{\n"
		    "\t\t&&bc0,\n" // because index 0 is meaningless
		);
		for (InsRef ins : get_bytecode(*state.fn)) {
			if (ins.opcode() == asBC_JitEntry && ins.pword0() != 0) {
				emit("\t\t&&bc{},\n", ins.offset);
			}
		}
		emit(
		    "\t}};\n"
		    "\tgoto *entry[entryLabel];\n\n"
		);
	} else {
		emit("\tswitch(entryLabel) {{\n");
		for (InsRef ins : get_bytecode(*state.fn)) {
			if (ins.opcode() == asBC_JitEntry && ins.pword0() != 0) {
				emit("\tcase {}: goto bc{};\n", ins.pword0(), ins.offset);
			}
		}
		emit("\t}};\n");
	}
}

void BytecodeToC::emit_error_handlers(FnState& state) {
	const auto requires_handler = [&](ErrorHandler handler) {
		return (std::uint64_t(state.error_handlers_mask) & std::uint64_t(handler)) != 0;
	};

	if (requires_handler(ErrorHandler::ERR_NULL)) {
		emit(
		    "\terr_null:\n"
		    "\t\tasea_set_internal_exception(_regs, \"" TXT_NULL_POINTER_ACCESS
		    "\");\n"
		    "\t\tgoto vm;\n"
		    "\t\n"
		);
		state.error_handlers_mask |= std::uint64_t(ErrorHandler::VM_FALLBACK);
	}

	if (requires_handler(ErrorHandler::ERR_DIVIDE_BY_ZERO)) {
		emit(
		    "\terr_divide_by_zero:\n"
		    "\t\tasea_set_internal_exception(_regs, \"" TXT_DIVIDE_BY_ZERO
		    "\");\n"
		    "\t\tgoto vm;\n"
		    "\t\n"
		);
		state.error_handlers_mask |= std::uint64_t(ErrorHandler::VM_FALLBACK);
	}

	if (requires_handler(ErrorHandler::ERR_DIVIDE_OVERFLOW)) {
		emit(
		    "\terr_divide_overflow:\n"
		    "\t\tasea_set_internal_exception(_regs, \"" TXT_DIVIDE_OVERFLOW
		    "\");\n"
		    "\t\tgoto vm;\n"
		    "\t\n"
		);
		state.error_handlers_mask |= std::uint64_t(ErrorHandler::VM_FALLBACK);
	}

	if (requires_handler(ErrorHandler::VM_FALLBACK)) {
		emit("\tvm:\n");
		emit_save_sp(state);
		emit("\treturn;\n");
	}
}

bool BytecodeToC::is_instruction_blacklisted(asEBCInstr bc) const {
	return std::find(m_config->debug.blacklist_instructions.begin(), m_config->debug.blacklist_instructions.end(), bc)
	    != m_config->debug.blacklist_instructions.end();
}

void BytecodeToC::translate_instruction(FnState& state) {
	using namespace var_types;
	auto& ins = state.ins;

	if (m_config->c.human_readable) {
		emit("\t/* bytecode: {} */\n", disassemble(*m_script_engine, ins));
	}

	if (state.branch_targets.contains(ins.offset)) {
		emit("\tbc{}: {{\n", ins.offset);
	} else {
		if (m_config->c.human_readable) {
			emit("\t/* bc{}: */ {{\n", ins.offset);
		} else {
			emit("\t{{\n");
		}
	}

	if (is_instruction_blacklisted(ins.opcode())) {
		emit_vm_fallback(state, "instruction blacklisted by config.debug, force fallback");
		emit("\t}}\n");
		return;
	}

	const auto virt_visitor = overloaded{
	    [&](virtins::FusedCompareJump& fused) {
		    make_local_from_operand(state, "lhs", fused.compare.lhs);
		    make_local_from_operand(state, "rhs", fused.compare.rhs);
		    if (m_config->c.use_builtin_expect) {
			    emit(
			        "\t\tif (__builtin_expect(lhs {OP} rhs, {EXPECTED_BRANCH_VALUE})) {{ goto bc{TARGET}; }}\n",
			        fmt::arg("OP", fused.jump.cond_expr->c_comparison_op),
			        fmt::arg("TARGET", fused.jump.target_offset()),
			        fmt::arg("EXPECTED_BRANCH_VALUE", fused.jump.target_offset() < int(state.ins.offset) ? 1 : 0)
			    );
		    } else {
			    emit(
			        "\t\tif (lhs {OP} rhs) {{ goto bc{TARGET}; }}\n",
			        fmt::arg("OP", fused.jump.cond_expr->c_comparison_op),
			        fmt::arg("TARGET", fused.jump.target_offset())
			    );
		    }
	    },
	    [&](virtins::Nop&) {
		    if (m_config->c.human_readable) {
			    emit("\t\t/* no-op from fusing with another bytecodeinstruction */\n");
		    }
	    },
	};

	if (auto virt_it = state.overriden_instructions.find(ins.offset); virt_it != state.overriden_instructions.end()) {
		if (m_config->c.human_readable) {
			emit("\t\t/* Virtual instruction injected by optimizer */\n");
		}

		std::visit(virt_visitor, virt_it->second);

		// TODO: dedup footer here
		if (ins.opcode() == m_config->debug.fallback_after_instruction) {
			emit_vm_fallback(state, "debug.fallback_after_instruction");
		}

		emit("\t}}\n");
		return;
	}

	switch (ins.opcode()) {
	case asBC_JitEntry: break;
	case asBC_STR:      emit_vm_fallback(state, "deprecated instruction"); break;

	case asBC_SUSPEND:  {
		if (m_config->hack_ignore_suspend) {
			break;
		}
		emit_vm_fallback(state, "SUSPEND is not implemented yet");
		break;
	}

	case asBC_TYPEID:
	case asBC_PshC4:
	case asBC_PshV4:
	case asBC_PshG4:
	case asBC_PshC8:
	case asBC_PshV8:
	case asBC_VAR:
	case asBC_PshNull:
	case asBC_PshVPtr:
	case asBC_PshGPtr:
	case asBC_PshRPtr:
	case asBC_PSF:
	case asBC_PGA:
	case asBC_OBJTYPE: emit_stack_push_ins(state, bcins::StackPush{ins}); break;

	case asBC_PopRPtr: {
		emit(
		    "\t\tvalue_reg = sp->as_asPWORD;\n"
		    "\t\tsp = (asea_var*)((char*)sp + sizeof(asPWORD));\n"
		);
		break;
	}
	case asBC_PopPtr: {
		emit("\t\tsp = (asea_var*)((char*)sp + sizeof(asPWORD));\n");
		break;
	}

	case asBC_RDSPtr: {
		emit(
		    "\t\tasPWORD* a = (asPWORD*)sp->as_ptr;\n"
		    "\t\tif (a == 0) {{ {ERR_NULL_HANDLER} }}\n"
		    "\t\tsp->as_asPWORD = *a;\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL))
		);
		break;
	}

	case asBC_CHKREF: {
		emit(
		    "\t\tif (sp->as_asPWORD == 0) {{ {ERR_NULL_HANDLER} }}\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL))
		);
		break;
	}

	case asBC_ChkNullV: {
		emit(
		    "\t\tif ({VAR} == 0) {{ {ERR_NULL_HANDLER} }}\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL)),
		    fmt::arg("VAR", frame_var(ins.sword0(), pword))
		);
		break;
	}

	case asBC_ChkNullS: {
		emit(
		    "\t\tif ({VAR} == 0) {{ {ERR_NULL_HANDLER} }}\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL)),
		    fmt::arg("VAR", stack_var(ins.word0(), pword))
		);
		break;
	}

	case asBC_ALLOC: {
		auto* type   = std::bit_cast<asCObjectType*>(ins.pword0());
		int   fn_idx = ins.int0(AS_PTR_SIZE);

		std::size_t alloc_size = type->size;
		if (alloc_size % 4 != 0) { // up-align to multiple of 4 bytes
			alloc_size += 4 - (alloc_size % 4);
		}

		if ((type->flags & asOBJ_SCRIPT_OBJECT) != 0) {
			asCScriptFunction& fn             = *m_script_engine->scriptFunctions[fn_idx];
			const auto         objtype_symbol = emit_type_info_lookup(state, *type);
			emit(
			    "\t\tvoid* new_obj = asea_new_script_object((asCObjectType*)&{OBJECT_TYPE});\n"
			    "\t\tvoid **a = (void**)((asea_var*)((asDWORD*)sp + {ARG_SPACE}))->as_ptr;\n"
			    "\t\tif (a) {{ *a = new_obj; }}\n"
			    "\t\tsp = (asea_var*)((char*)sp - sizeof(void*));\n"
			    "\t\tsp->as_ptr = new_obj;\n",
			    fmt::arg("OBJECT_TYPE", objtype_symbol),
			    fmt::arg("ARG_SPACE", fn.GetSpaceNeededForArguments())
			);
			emit_direct_script_call_ins(state, ScriptCallByIdx{fn_idx});
			break;
		}

		emit("\t\tasDWORD* mem = asea_alloc({ALLOC_SIZE});\n", fmt::arg("ALLOC_SIZE", alloc_size));

		if (fn_idx != 0) {
			// define as an internal call, but we'll have to pop from the stack as a consequence
			emit_system_call(state, {.fn_idx = fn_idx, .object_pointer_override = {"mem"}, .is_internal_call = false});
			// FIXME: suspend
		}

		emit(
		    "\t\tasDWORD** a = (asDWORD**)(sp->as_ptr);\n"
		    "\t\tsp = (asea_var*)((char*)sp + sizeof(asPWORD));\n"
		    "\t\tif (a) *a = mem;\n"
		);

		break;
	}

	case asBC_FREE: {
		auto*             type = std::bit_cast<asCObjectType*>(ins.pword0());
		asSTypeBehaviour& beh  = type->beh;

		if ((type->flags & asOBJ_LIST_PATTERN) != 0) {
			emit_vm_fallback(state, "Can't handle FREE of list patterns yet");
			break;
		}

		emit(
		    "\t\tasPWORD *a = &{}, v = *a;\n"
		    "\t\tif (v) {{\n",
		    frame_var(ins.sword0(), pword)
		);
		if ((type->flags & asOBJ_REF) != 0) {
			if (beh.release != 0) {
				emit_system_call(
				    state,
				    {.fn_idx = beh.release, .object_pointer_override = "(void*)v", .is_internal_call = true}
				);
			}
		} else {
			if (beh.destruct != 0) {
				emit_system_call(
				    state,
				    {.fn_idx = beh.destruct, .object_pointer_override = "(void*)v", .is_internal_call = true}
				);
			} // TODO: LIST_PATTERN
			emit("\t\t\tasea_free((void*)v);\n");
		}
		emit(
		    "\t\t\t*a = 0;\n"
		    "\t\t}}\n"
		);

		break;
	}

	case asBC_COPY: {
		emit(
		    "\t\tvoid *dst = sp->as_ptr;\n"
		    "\t\tsp = (asea_var*)((char*)sp + sizeof(void*));\n"
		    "\t\tvoid *src = sp->as_ptr;\n"
		    "\t\tif (!src || !dst) {{ {ERR_NULL_HANDLER} }}\n"
		    "\t\tmemcpy(dst, src, {COUNT});\n"
		    "\t\tsp->as_ptr = dst;\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL)),
		    fmt::arg("COUNT", ins.word0() * sizeof(asDWORD))
		);
		break;
	}

	// V1/V2 are equivalent to V4
	case asBC_SetV1:
	case asBC_SetV2:
	case asBC_SetV4:    emit_assign_ins(state, frame_var(ins.sword0(), u32), imm_int(ins.dword0(), u32)); break;
	case asBC_SetV8:    emit_assign_ins(state, frame_var(ins.sword0(), u64), imm_int(ins.qword0(), u64)); break;

	case asBC_ClrVPtr:  emit_assign_ins(state, frame_var(ins.sword0(), pword), "0"); break;

	case asBC_CpyVtoR4: emit_assign_ins(state, "value_reg", frame_var(ins.sword0(), u32)); break;
	case asBC_CpyRtoV4: emit_assign_ins(state, frame_var(ins.sword0(), u32), "value_reg"); break;
	case asBC_CpyVtoR8: emit_assign_ins(state, "value_reg", frame_var(ins.sword0(), u64)); break;
	case asBC_CpyRtoV8: emit_assign_ins(state, frame_var(ins.sword0(), u64), "value_reg"); break;
	case asBC_CpyVtoV4: emit_assign_ins(state, frame_var(ins.sword0(), u32), frame_var(ins.sword1(), u32)); break;
	case asBC_CpyVtoV8: emit_assign_ins(state, frame_var(ins.sword0(), u64), frame_var(ins.sword1(), u64)); break;

	case asBC_CpyVtoG4: {
		std::string symbol = emit_global_lookup(state, std::bit_cast<void*>(ins.pword0()), true);
		emit_assign_ins(state, fmt::format("*(asDWORD*)&{}", symbol), frame_var(ins.sword0(), u32));
		break;
	}
	case asBC_CpyGtoV4: {
		std::string symbol = emit_global_lookup(state, std::bit_cast<void*>(ins.pword0()), true);
		emit_assign_ins(state, frame_var(ins.sword0(), u32), fmt::format("*(asDWORD*)&{}", symbol));
		break;
	}

	case asBC_LDV:   emit_assign_ins(state, "value_reg", fmt::format("(asPWORD){}", frame_ptr(ins.sword0()))); break;

	case asBC_SetG4: {
		std::string symbol = emit_global_lookup(state, std::bit_cast<void*>(ins.pword0()), true);
		emit_assign_ins(state, fmt::format("*(asDWORD*)&{}", symbol), fmt::to_string(ins.dword0(AS_PTR_SIZE)));
		break;
	}

	case asBC_LDG: {
		std::string symbol = emit_global_lookup(state, std::bit_cast<void*>(ins.pword0()), true);
		emit("\t\tvalue_reg = (asPWORD)&{};\n", symbol);
		break;
	}

	case asBC_RefCpyV: {
		auto*             type = std::bit_cast<asCObjectType*>(ins.pword0());
		asSTypeBehaviour& beh  = type->beh;

		emit(
		    "\t\tasPWORD src = sp->as_asPWORD;\n"
		    "\t\tasPWORD* dst = &{DST};\n",
		    fmt::arg("DST", frame_var(ins.sword0(), pword))
		);

		if ((type->flags & (asOBJ_NOCOUNT | asOBJ_VALUE)) == 0) {
			// TODO: fix indent within call
			if (beh.release != 0) {
				emit("\t\tif (*dst != 0) {{\n");
				emit_system_call(
				    state,
				    {.fn_idx = beh.release, .object_pointer_override = "(void*)*dst", .is_internal_call = true}
				);
				emit("\t\t}}\n");
			}

			if (beh.addref != 0) {
				emit("\t\tif (src != 0) {{\n");
				emit_system_call(
				    state,
				    {.fn_idx = beh.addref, .object_pointer_override = "(void*)src", .is_internal_call = true}
				);
				emit("\t\t}}\n");
			}
		}

		emit("\t\t*dst = src;\n");

		break;
	}

	case asBC_REFCPY: {
		auto*             type = std::bit_cast<asCObjectType*>(ins.pword0());
		asSTypeBehaviour& beh  = type->beh;

		emit(
		    "\t\tasPWORD *dst = (asPWORD*)sp->as_asPWORD;\n"
		    "\t\tsp = (asea_var*)((char*)sp + sizeof(asPWORD));\n"
		    "\t\tasPWORD src = sp->as_asPWORD;\n",
		    fmt::arg("SWORD0", ins.sword0())
		);

		if ((type->flags & (asOBJ_NOCOUNT | asOBJ_VALUE)) == 0) {
			// TODO: fix indent within call
			// TODO: dedup with RefCpyV
			if (beh.release != 0) {
				emit("\t\tif (*dst != 0) {{\n");
				emit_system_call(
				    state,
				    {.fn_idx = beh.release, .object_pointer_override = "(void*)*dst", .is_internal_call = true}
				);
				emit("\t\t}}\n");
			}

			if (beh.addref != 0) {
				emit("\t\tif (src != 0) {{\n");
				emit_system_call(
				    state,
				    {.fn_idx = beh.addref, .object_pointer_override = "(void*)src", .is_internal_call = true}
				);
				emit("\t\t}}\n");
			}
		}

		emit("\t\t*dst = src;\n");

		break;
	}

	case asBC_LOADOBJ: {
		emit(
		    "\t\tvoid **a = &{VARPTR}->as_ptr;\n"
		    "\t\tregs->obj_type = 0;\n"
		    "\t\tregs->obj = *a;\n"
		    "\t\t*a = 0;\n",
		    fmt::arg("VARPTR", frame_ptr(ins.sword0()))
		);
		break;
	}

	case asBC_STOREOBJ: {
		emit(
		    "\t\t{VARPTR}->as_ptr = regs->obj;\n"
		    "\t\tregs->obj = 0;\n",
		    fmt::arg("VARPTR", frame_ptr(ins.sword0()))
		);

		break;
	}

	case asBC_GETOBJ: {
		emit(
		    "\t\tasPWORD *a = &{VAR};\n"
		    "\t\tasPWORD offset = *a;\n"
		    "\t\tasPWORD *v = &{OBJPTR};\n"
		    "\t\t*a = *v;\n"
		    "\t\t*v = 0;\n",
		    fmt::arg("VAR", stack_var(ins.word0(), pword)),
		    fmt::arg("OBJPTR", frame_var("offset", pword))
		);
		break;
	}

	case asBC_GETOBJREF: {
		emit(
		    "\t\tasPWORD *obj = &{VAR};\n"
		    "\t\t{VAR} = {VARDEREF};\n",
		    fmt::arg("VAR", stack_var(ins.word0(), pword)),
		    fmt::arg("VARDEREF", frame_var("*obj", pword))
		);
		break;
	}

	case asBC_GETREF: {
		emit(
		    "\t\tasPWORD *var_idx = &{VAR};\n"
		    "\t\t{VAR} = (asPWORD){VARDEREF};\n",
		    fmt::arg("VAR", stack_var(ins.word0(), pword)),
		    fmt::arg("VARDEREF", frame_ptr("(int)*var_idx"))
		);
		break;
	}

	case asBC_LoadRObjR: {
		emit(
		    "\t\tasPWORD base = {VAR};\n"
		    "\t\tif (base == 0) {{ {ERR_NULL_HANDLER} }}\n"
		    "\t\tvalue_reg = base + {SWORD1};\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL)),
		    fmt::arg("VAR", frame_var(ins.sword0(), pword)),
		    fmt::arg("SWORD1", ins.sword1())
		);
		break;
	}

	case asBC_LoadVObjR: {
		emit(
		    "\t\tvalue_reg = (asPWORD){BASE_PTR} + {OFF};\n",
		    fmt::arg("BASE_PTR", frame_ptr(ins.sword0())),
		    fmt::arg("OFF", ins.sword1())
		);
		break;
	}

	case asBC_LoadThisR: {
		emit(
		    "\t\tasPWORD base = {THIS};\n"
		    "\t\tif (base == 0) {{ {ERR_NULL_HANDLER} }}\n"
		    "\t\tvalue_reg = base + {SWORD0};\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL)),
		    fmt::arg("THIS", frame_var(0, pword)),
		    fmt::arg("SWORD0", ins.sword0())
		);
		break;
	}

	// FIXME: strict aliasing
	case asBC_WRTV1: emit_assign_ins(state, "((asea_var*)value_reg)->as_asBYTE", frame_var(ins.sword0(), u8)); break;
	case asBC_WRTV2: emit_assign_ins(state, "((asea_var*)value_reg)->as_asWORD", frame_var(ins.sword0(), u16)); break;
	case asBC_WRTV4: emit_assign_ins(state, "((asea_var*)value_reg)->as_asDWORD", frame_var(ins.sword0(), u32)); break;
	case asBC_WRTV8: emit_assign_ins(state, "((asea_var*)value_reg)->as_asQWORD", frame_var(ins.sword0(), u64)); break;

	case asBC_RDR1:  {
		emit(
		    "\t\tasea_var* var = {VARPTR};\n"
		    "\t\tvar->as_asDWORD = ((asea_var*)value_reg)->as_asBYTE;\n",
		    fmt::arg("VARPTR", frame_ptr(ins.sword0()))
		);
		break;
	}
	case asBC_RDR2: {
		emit(
		    "\t\tasea_var* var = {VARPTR};\n"
		    "\t\tvar->as_asDWORD = ((asea_var*)value_reg)->as_asWORD;\n",
		    fmt::arg("VARPTR", frame_ptr(ins.sword0()))
		);
		break;
	}
	case asBC_RDR4: emit_assign_ins(state, frame_var(ins.sword0(), u32), "((asea_var*)value_reg)->as_asDWORD"); break;
	case asBC_RDR8: emit_assign_ins(state, frame_var(ins.sword0(), u64), "((asea_var*)value_reg)->as_asQWORD"); break;

	case asBC_Cast: {
		emit(
		    "\t\tasCScriptObject** h = (asCScriptObject**)sp->as_ptr;\n"
		    "\t\tif (h && *h) {{ asea_cast(_regs, *h, {TYPEID}); }}\n"
		    "\t\tsp = (asea_var*)((char*)sp + sizeof(asPWORD));\n",
		    fmt::arg("TYPEID", ins.dword0())
		);
		break;
	}

	case asBC_CALL:     emit_direct_script_call_ins(state, ScriptCallByIdx{ins.int0()}); break;
	case asBC_CALLINTF: {
		// TODO: devirtualization optimization using `final` like asllvm did -- in fact, could we infer `final`
		// ourselves? i don't know if we can look at the descendants safely from within our module

		const auto fn_idx = ins.int0();
		// const std::string  fn_symbol = fmt::format("{}_scriptfn{}", m_c_symbol_prefix, fn_idx);
		asCScriptFunction* virtual_fn = m_script_engine->scriptFunctions[fn_idx];

		if (virtual_fn->funcType == asFUNC_INTERFACE) {
			// TODO: write tests with a few interfaces then implement
			emit_vm_fallback(state, "Cannot handle interface calls yet");
			break;
		}

		// FIXME: if v_obj is null then null exception

		emit(
		    "\t\tasCScriptObject* v_obj = sp->as_ptr;\n"
		    "\t\tasITypeInfo* v_obj_type = *(asITypeInfo**)((char*)v_obj + {OFF_SCRIPTOBJ_OBJTYPE});\n"
		    "\t\tasea_array* v_vftable = (asea_array*)((char*)v_obj_type + {OFF_OBJTYPE_VFTABLE});\n"
		    "\t\tasCScriptFunction* v_fn = ((asCScriptFunction**)(v_vftable->ptr))[{VTABLE_IDX}];\n",
		    fmt::arg("OFF_SCRIPTOBJ_OBJTYPE", DIRECT_VALUE_IF_POSSIBLE(asea_offset_scriptobj_objtype)),
		    fmt::arg("OFF_OBJTYPE_VFTABLE", DIRECT_VALUE_IF_POSSIBLE(asea_offset_objtype_vtable)),
		    fmt::arg("VTABLE_IDX", virtual_fn->vfTableIdx)
		);
		emit_direct_script_call_ins(state, ScriptCallByExpr{.fn_decl = virtual_fn, .expr = "v_fn"});
		break;
	}

	case asBC_Thiscall1:
	case asBC_CALLSYS:   {
		emit_system_call(
		    state,
		    SystemCall{.fn_idx = ins.int0(), .object_pointer_override = {}, .is_internal_call = false}
		);
		break;
	}

	case asBC_RET: {
		if (!m_config->experimental_fast_script_return) {
			emit_vm_fallback(state, "experimental_fast_script_return == false");
			break;
		}

		emit(
		    "\t\tasea_array* cs = (asea_array*)((char*)regs->ctx + {OFF_CALLSTACK});\n"
		    "\t\tasPWORD* cs_ptr = (asPWORD*)(cs->ptr);\n"
		    "\t\tif (cs->len == 0 || cs_ptr[cs->len - {FRAMESIZE}] == 0) {{\n"
		    "\t\t\t*(int*)((char*)regs->ctx + {OFF_STATUS}) = asEXECUTION_FINISHED;\n"
		    "\t\t\tregs->value = value_reg;\n"
		    "\t\t\treturn;\n"
		    "\t\t}}\n"
		    "\t\tasUINT new_len = cs->len - {FRAMESIZE};\n"
		    "\t\tasPWORD* tmp = cs_ptr + new_len;\n"
		    "\t\tregs->fp = (asDWORD*)tmp[0];\n"
		    "\t\t*(asCScriptFunction**)((char*)regs->ctx + {OFF_CURRENTFN}) = (asCScriptFunction*)tmp[1];\n"
		    "\t\tregs->pc = (asDWORD*)tmp[2];\n"
		    "\t\tregs->sp = (asDWORD*)tmp[3] + {POP};\n"
		    "\t\t*(asUINT*)((char*)regs->ctx + {OFF_STACKINDEX}) = (asUINT)tmp[4];\n"
		    "\t\tcs->len = new_len;\n"
		    "\t\tregs->value = value_reg;\n"
		    "\t\treturn;\n",
		    fmt::arg("OFF_CALLSTACK", DIRECT_VALUE_IF_POSSIBLE(asea_offset_ctx_callstack)),
		    fmt::arg("OFF_STATUS", DIRECT_VALUE_IF_POSSIBLE(asea_offset_ctx_status)),
		    fmt::arg("OFF_CURRENTFN", DIRECT_VALUE_IF_POSSIBLE(asea_offset_ctx_currentfn)),
		    fmt::arg("OFF_STACKINDEX", DIRECT_VALUE_IF_POSSIBLE(asea_offset_ctx_stackindex)),
		    fmt::arg("FRAMESIZE", CALLSTACK_FRAME_SIZE),
		    fmt::arg("POP", ins.word0())
		);
		break;
	}

	case asBC_JMP:  emit("\t\tgoto bc{};\n", bcins::Jump{ins}.target_offset()); break;

	case asBC_JMPP: {
		emit("\t\tswitch({}) {{\n", frame_var(ins.sword0(), s32));
		auto mapping_it = state.switch_map.find(ins.offset);
		angelsea_assert(mapping_it != state.switch_map.end());
		std::size_t i = 0;
		// TODO: also investigate label as values for this
		for (const std::size_t target : mapping_it->second) {
			emit("\t\tcase {}: goto bc{};\n", i, target);
			++i;
		}
		emit("\t\t}}\n");
		break;
	}

	case asBC_NOT: {
		emit(
		    "\t\tasea_var *var = {VARPTR};\n"
		    "\t\tasDWORD value = var->as_asBYTE;\n"
		    "\t\tvar->as_asDWORD = 0;\n"
		    "\t\tvar->as_asBYTE = !value;\n",
		    fmt::arg("VARPTR", frame_ptr(ins.sword0()))
		);
		break;
	}

	case asBC_ADDSi: {
		// NOTE: memory GVN: if we store &ASEA_STACK_TOP.as_asPWORD to a temporary and use it, then we get
		// corruption with load GVN (angelsea -O3 mode as of writing), again.
		emit(
		    "\t\tif (sp->as_asPWORD == 0) {{ {ERR_NULL_HANDLER} }}\n"
		    "\t\tsp->as_asPWORD += {SWORD0};\n",
		    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL)),
		    fmt::arg("SWORD0", ins.sword0())
		);
		break;
	}

	case asBC_IncVi: {
		emit("\t\t++{};\n", frame_var(ins.sword0(), u32));
		break;
	}

	case asBC_DecVi: {
		emit("\t\t--{};\n", frame_var(ins.sword0(), u32));
		break;
	}

	case asBC_JZ:
	case asBC_JLowZ:
	case asBC_JNZ:
	case asBC_JLowNZ:
	case asBC_JS:
	case asBC_JNS:
	case asBC_JP:
	case asBC_JNP:    {
		bcins::Jump jmp{ins};
		emit_cond_branch(
		    state,
		    fmt::format(
		        "({TYPE})value_reg {OP} 0",
		        fmt::arg("TYPE", jmp.cond_expr->lhs_type.c),
		        fmt::arg("OP", jmp.cond_expr->c_comparison_op)
		    ),
		    jmp.target_offset()
		);
		break;
	}

	case asBC_TZ:     emit_test_ins(state, "=="); break;
	case asBC_TNZ:    emit_test_ins(state, "!="); break;
	case asBC_TS:     emit_test_ins(state, "<"); break;
	case asBC_TNS:    emit_test_ins(state, ">="); break;
	case asBC_TP:     emit_test_ins(state, ">"); break;
	case asBC_TNP:    emit_test_ins(state, "<="); break;

	case asBC_CMPi:
	case asBC_CMPu:
	case asBC_CMPd:
	case asBC_CMPf:
	case asBC_CMPi64:
	case asBC_CMPu64:
	case asBC_CmpPtr:
	case asBC_CMPIi:
	case asBC_CMPIu:
	case asBC_CMPIf:  emit_compare(state, bcins::Compare{ins}); break;

	case asBC_INCi8:  emit_prefixop_valuereg_ins(state, "++", u8); break;
	case asBC_DECi8:  emit_prefixop_valuereg_ins(state, "--", u8); break;
	case asBC_INCi16: emit_prefixop_valuereg_ins(state, "++", u16); break;
	case asBC_DECi16: emit_prefixop_valuereg_ins(state, "--", u16); break;
	case asBC_INCi:   emit_prefixop_valuereg_ins(state, "++", u32); break;
	case asBC_DECi:   emit_prefixop_valuereg_ins(state, "--", u32); break;
	case asBC_INCi64: emit_prefixop_valuereg_ins(state, "++", u64); break;
	case asBC_DECi64: emit_prefixop_valuereg_ins(state, "--", u64); break;
	case asBC_INCf:   emit_prefixop_valuereg_ins(state, "++", f32); break;
	case asBC_DECf:   emit_prefixop_valuereg_ins(state, "--", f32); break;
	case asBC_INCd:   emit_prefixop_valuereg_ins(state, "++", f64); break;
	case asBC_DECd:   emit_prefixop_valuereg_ins(state, "--", f64); break;

	case asBC_NEGi:   emit_unop_var_inplace_ins(state, "-", s32); break;
	case asBC_NEGi64: emit_unop_var_inplace_ins(state, "-", s64); break;
	case asBC_NEGf:   emit_unop_var_inplace_ins(state, "-", f32); break;
	case asBC_NEGd:   emit_unop_var_inplace_ins(state, "-", f64); break;

	case asBC_ADDi:   emit_binop_var_var_ins(state, "+", s32, s32, s32); break;
	case asBC_SUBi:   emit_binop_var_var_ins(state, "-", s32, s32, s32); break;
	case asBC_MULi:   emit_binop_var_var_ins(state, "*", s32, s32, s32); break;
	case asBC_ADDi64: emit_binop_var_var_ins(state, "+", s64, s64, s64); break;
	case asBC_SUBi64: emit_binop_var_var_ins(state, "-", s64, s64, s64); break;
	case asBC_MULi64: emit_binop_var_var_ins(state, "*", s64, s64, s64); break;
	case asBC_ADDf:   emit_binop_var_var_ins(state, "+", f32, f32, f32); break;
	case asBC_SUBf:   emit_binop_var_var_ins(state, "-", f32, f32, f32); break;
	case asBC_MULf:   emit_binop_var_var_ins(state, "*", f32, f32, f32); break;
	case asBC_ADDd:   emit_binop_var_var_ins(state, "+", f64, f64, f64); break;
	case asBC_SUBd:   emit_binop_var_var_ins(state, "-", f64, f64, f64); break;
	case asBC_MULd:   emit_binop_var_var_ins(state, "*", f64, f64, f64); break;

	case asBC_DIVi:   emit_divmod_var_int_ins(state, "/", 0x80000000, s32); break;
	case asBC_MODi:   emit_divmod_var_int_ins(state, "%", 0x80000000, s32); break;
	case asBC_DIVu:   emit_divmod_var_unsigned_ins(state, "/", u32); break;
	case asBC_MODu:   emit_divmod_var_unsigned_ins(state, "%", u32); break;
	case asBC_DIVi64: emit_divmod_var_int_ins(state, "/", asINT64(1) << 63, s64); break;
	case asBC_MODi64: emit_divmod_var_int_ins(state, "%", asINT64(1) << 63, s64); break;
	case asBC_DIVu64: emit_divmod_var_unsigned_ins(state, "/", u64); break;
	case asBC_MODu64: emit_divmod_var_unsigned_ins(state, "%", u64); break;

	case asBC_DIVf:   emit_divmod_var_float_ins(state, "ASEA_FDIV", f32); break;
	case asBC_DIVd:   emit_divmod_var_float_ins(state, "ASEA_FDIV", f64); break;
	case asBC_MODf:   emit_divmod_var_float_ins(state, "fmodf", f32); break;
	case asBC_MODd:   emit_divmod_var_float_ins(state, "fmod", f64); break;

	case asBC_BNOT64: emit_unop_var_inplace_ins(state, "~", u64); break;
	case asBC_BAND64: emit_binop_var_var_ins(state, "&", u64, u64, u64); break;
	case asBC_BXOR64: emit_binop_var_var_ins(state, "^", u64, u64, u64); break;
	case asBC_BOR64:  emit_binop_var_var_ins(state, "|", u64, u64, u64); break;
	case asBC_BSLL64: emit_binop_var_var_ins(state, "<<", u64, u32, u64); break;
	case asBC_BSRL64: emit_binop_var_var_ins(state, ">>", u64, u32, u64); break;
	case asBC_BSRA64: emit_binop_var_var_ins(state, ">>", s64, u32, s64); break;

	case asBC_BNOT:   emit_unop_var_inplace_ins(state, "~", u32); break;
	case asBC_BAND:   emit_binop_var_var_ins(state, "&", u32, u32, u32); break;
	case asBC_BXOR:   emit_binop_var_var_ins(state, "^", u32, u32, u32); break;
	case asBC_BOR:    emit_binop_var_var_ins(state, "|", u32, u32, u32); break;
	case asBC_BSLL:   emit_binop_var_var_ins(state, "<<", u32, u32, u32); break;
	case asBC_BSRL:   emit_binop_var_var_ins(state, ">>", u32, u32, u32); break;
	case asBC_BSRA:   emit_binop_var_var_ins(state, ">>", s32, u32, s32); break;

	case asBC_iTOf:   emit_primitive_cast_var_ins(state, s32, f32); break;
	case asBC_fTOi:   emit_primitive_cast_var_ins(state, f32, s32); break;
	case asBC_uTOf:   emit_primitive_cast_var_ins(state, u32, f32); break;
	case asBC_fTOu:   emit_primitive_cast_var_ins(state, f32, u32); break;
	case asBC_sbTOi:  emit_primitive_cast_var_ins(state, s8, s32); break;
	case asBC_swTOi:  emit_primitive_cast_var_ins(state, s16, s32); break;
	case asBC_ubTOi:  emit_primitive_cast_var_ins(state, u8, s32); break;
	case asBC_uwTOi:  emit_primitive_cast_var_ins(state, u16, s32); break;
	case asBC_iTOb:   emit_primitive_cast_var_ins(state, u32, s8); break;
	case asBC_iTOw:   emit_primitive_cast_var_ins(state, u32, s16); break;
	case asBC_i64TOi: emit_primitive_cast_var_ins(state, s64, s32); break;
	case asBC_uTOi64: emit_primitive_cast_var_ins(state, u32, s64); break;
	case asBC_iTOi64: emit_primitive_cast_var_ins(state, s32, s64); break;
	case asBC_fTOd:   emit_primitive_cast_var_ins(state, f32, f64); break;
	case asBC_dTOf:   emit_primitive_cast_var_ins(state, f64, f32); break;
	case asBC_fTOi64: emit_primitive_cast_var_ins(state, f32, s64); break;
	case asBC_dTOi64: emit_primitive_cast_var_ins(state, f64, s64); break;
	case asBC_fTOu64: emit_primitive_cast_var_ins(state, f32, u64); break;
	case asBC_dTOu64: emit_primitive_cast_var_ins(state, f64, u64); break;
	case asBC_i64TOf: emit_primitive_cast_var_ins(state, s64, f32); break;
	case asBC_u64TOf: emit_primitive_cast_var_ins(state, u64, f32); break;
	case asBC_i64TOd: emit_primitive_cast_var_ins(state, s64, f64); break;
	case asBC_u64TOd: emit_primitive_cast_var_ins(state, u64, f64); break;
	case asBC_dTOi:   emit_primitive_cast_var_ins(state, f64, s32); break;
	case asBC_dTOu:   emit_primitive_cast_var_ins(state, f64, u32); break;
	case asBC_iTOd:   emit_primitive_cast_var_ins(state, s32, f64); break;
	case asBC_uTOd:   emit_primitive_cast_var_ins(state, u32, f64); break;

	case asBC_ADDIi:  emit_binop_var_imm_ins(state, "+", s32, fmt::to_string(ins.int0(1)), s32); break;
	case asBC_SUBIi:  emit_binop_var_imm_ins(state, "-", s32, fmt::to_string(ins.int0(1)), s32); break;
	case asBC_MULIi:  emit_binop_var_imm_ins(state, "*", s32, fmt::to_string(ins.int0(1)), s32); break;

	case asBC_ADDIf:
		emit("\t\tasea_i2f rhs_i2f = {{.i={}}};\n", ins.dword0(1));
		emit_binop_var_imm_ins(state, "+", f32, "rhs_i2f.f", f32);
		break;
	case asBC_SUBIf:
		emit("\t\tasea_i2f rhs_i2f = {{.i={}}};\n", ins.dword0(1));
		emit_binop_var_imm_ins(state, "-", f32, "rhs_i2f.f", f32);
		break;
	case asBC_MULIf:
		emit("\t\tasea_i2f rhs_i2f = {{.i={}}};\n", ins.dword0(1));
		emit_binop_var_imm_ins(state, "*", f32, "rhs_i2f.f", f32);
		break;

	case asBC_SwapPtr:      // TODO: find way to emit
	case asBC_LdGRdR4:      // TODO: find way to emit
	case asBC_CALLBND:      // TODO: find way to emit & implement (calls & syscalls)
	case asBC_CallPtr:      // TODO: find way to emit & implement (calls & syscalls) -- probably just functors
	case asBC_ChkRefS:      // TODO: find way to emit
	case asBC_ClrHi:        // TODO: find way to emit
	case asBC_FuncPtr:      // TODO: find way to emit
	case asBC_AllocMem:     // TODO: implement (seems used in list factories)
	case asBC_SetListSize:  // TODO: implement
	case asBC_PshListElmnt: // TODO: implement
	case asBC_SetListType:  // TODO: find way to emit
	case asBC_POWi:         // TODO: write tests and implement
	case asBC_POWu:         // TODO: write tests and implement
	case asBC_POWf:         // TODO: write tests and implement
	case asBC_POWd:         // TODO: write tests and implement
	case asBC_POWdi:        // TODO: write tests and implement
	case asBC_POWi64:       // TODO: write tests and implement
	case asBC_POWu64:       // TODO: write tests and implement
	{
		emit_vm_fallback(state, "unsupported instruction");
		break;
	}

	default: {
		emit_vm_fallback(state, "unknown instruction");
		break;
	}
	}

	if (ins.opcode() == m_config->debug.fallback_after_instruction) {
		emit_vm_fallback(state, "debug.fallback_after_instruction");
	}

	emit("\t}}\n");
}

void BytecodeToC::emit_vm_fallback(FnState& state, std::string_view reason) {
	++m_module_state.fallback_count;

	if (m_config->c.human_readable) {
		emit("\t\t{} /* {} */\n", jump_to_error_handler_code(state, ErrorHandler::VM_FALLBACK), reason);
	} else {
		emit("\t\t{}\n", jump_to_error_handler_code(state, ErrorHandler::VM_FALLBACK));
	}
}

std::string BytecodeToC::jump_to_error_handler_code(FnState& state, ErrorHandler handler) {
	state.error_handlers_mask |= std::uint64_t(handler);

	std::string_view handler_name;
	switch (handler) {
	case ErrorHandler::VM_FALLBACK:         handler_name = "vm"; break;
	case ErrorHandler::ERR_NULL:            handler_name = "err_null"; break;
	case ErrorHandler::ERR_DIVIDE_BY_ZERO:  handler_name = "err_divide_by_zero"; break;
	case ErrorHandler::ERR_DIVIDE_OVERFLOW: handler_name = "err_divide_overflow"; break;
	}

	return fmt::format(
	    "regs->pc = base_pc + {INS_OFFSET}; "
	    "goto {HANDLER};",
	    fmt::arg("INS_OFFSET", state.ins.offset),
	    fmt::arg("HANDLER", handler_name)
	);
}

// we don't ever need to save the fp back to the VM registers because the fp is constant within a function, and
// initialized from the VM registers. it will be saved and reloaded as part of the call state or elsewhere by  the
// AS engine, but that is distinct from the register save sequence.

void BytecodeToC::emit_save_sp([[maybe_unused]] FnState& state) { emit("\t\tregs->sp = sp;\n"); }
void BytecodeToC::emit_save_pc(FnState& state, bool next_pc) {
	emit(
	    "\t\tregs->pc = base_pc + {INS_OFFSET};\n",
	    fmt::arg("INS_OFFSET", state.ins.offset + (next_pc ? state.ins.size() : 0))
	);
}
void BytecodeToC::emit_primitive_cast_var_ins(FnState& state, VarType src, VarType dst) {
	InsRef&    ins      = state.ins;
	const bool in_place = ins.size() == 1;

	if (src.size != dst.size && dst.size < 4) {
		emit(
		    "\t\t{DST_TYPE} value = {SRC};\n"
		    "\t\tasea_var *dst = {DSTPTR};\n"
		    "\t\tdst->as_asDWORD = 0;\n"
		    "\t\tdst->as_{DST_TYPE} = value;\n",
		    fmt::arg("DST_TYPE", dst.c),
		    fmt::arg("DSTPTR", frame_ptr(ins.sword0())),
		    fmt::arg("SRC", frame_var(in_place ? ins.sword0() : ins.sword1(), src))
		);
		return;
	}
	emit_assign_ins(state, frame_var(ins.sword0(), dst), frame_var(in_place ? ins.sword0() : ins.sword1(), src));
}

std::string
BytecodeToC::emit_global_lookup([[maybe_unused]] FnState& state, void* pointer, [[maybe_unused]] bool global_var_only) {
	std::string                            fn_symbol;
	asSMapNode<void*, asCGlobalProperty*>* var_cursor = nullptr;
	if (m_script_engine->varAddressMap.MoveTo(&var_cursor, pointer)) {
		asCGlobalProperty* property = m_script_engine->varAddressMap.GetValue(var_cursor);
		angelsea_assert(property != nullptr);

		fn_symbol = fmt::format("{}_g{}", m_c_symbol_prefix, property->id);

		if (m_on_map_extern_callback) {
			m_on_map_extern_callback(
			    fn_symbol.c_str(),
			    ExternGlobalVariable{.ptr = pointer, .property = property},
			    pointer
			);
		}
	} else {
		// pointer to a string constant (of an arbitrary registered string type)

		// TODO: deduplicate references to identical strings

		angelsea_assert(!global_var_only);

		fn_symbol = fmt::format("{}_mod{}_str{}", m_c_symbol_prefix, m_module_idx, m_module_state.string_constant_idx);

		if (m_on_map_extern_callback) {
			m_on_map_extern_callback(fn_symbol.c_str(), ExternStringConstant{pointer}, pointer);
		}

		++m_module_state.string_constant_idx;
	}

	emit_forward_declaration(state, fn_symbol, "extern void* {};\n", fn_symbol);
	return fn_symbol;
}

std::string BytecodeToC::emit_type_info_lookup([[maybe_unused]] FnState& state, asITypeInfo& type) {
	const std::string type_info_symbol
	    = fmt::format("{}_mod{}_typeinfo{}", m_c_symbol_prefix, m_module_idx, m_module_state.type_info_idx);
	++m_module_state.type_info_idx;

	// if (m_config->c.human_readable) {
	// 	emit("\t\t/* type info `{}` */\n", type.GetName());
	// }
	emit_forward_declaration(state, type_info_symbol, "extern char {}[];\n", type_info_symbol);
	if (m_on_map_extern_callback) {
		m_on_map_extern_callback(type_info_symbol.c_str(), ExternTypeInfo{&type}, &type);
	}

	return type_info_symbol;
}

bool BytecodeToC::is_complex_passed_by_value(const asCDataType& type) const {
	if (!type.IsObject() || type.IsReference()) {
		return false;
	}

	if (type.GetTypeInfo() == nullptr) {
		return false;
	}

	const auto& type_info = *type.GetTypeInfo();
	const auto& flags     = type_info.flags;

	return (flags & (asOBJ_APP_CLASS_DESTRUCTOR | asOBJ_APP_CLASS_COPY_CONSTRUCTOR | asOBJ_APP_ARRAY)) != 0;
}

std::string BytecodeToC::emit_dummy_struct_declaration(FnState& state, const asCDataType& type) {
	if (type.GetTypeInfo() == nullptr) {
		return {};
	}

	const auto&       type_info = *type.GetTypeInfo();
	const auto&       flags     = type_info.flags;
	const std::size_t size      = type.GetSizeInMemoryBytes();

	if (is_complex_passed_by_value(type)) {
		log(*m_config,
		    *m_script_engine,
		    LogSeverity::ASEA_PERF_HINT,
		    "Type `{}` has non-trivial C++ ABI, which we currently don't emulate pass/return by value yet for. "
		    "Native "
		    "call will fall back to VM.",
		    type_info.GetName());
		return {};
	}

	std::string gen_name = fmt::format("{}_abi{}", m_c_symbol_prefix, type_info.GetTypeId());
	std::string decl     = "typedef struct { ";

	if ((flags & (asOBJ_APP_CLASS_ALLFLOATS | asOBJ_APP_FLOAT)) != 0) {
		// FIXME: how does this behave across ABIs with float/double
		for (std::size_t i = 0; i < size; i += 4) {
			decl += fmt::format("float _{}; ", i);
		}
	} else if ((flags & (asOBJ_APP_CLASS_ALLINTS | asOBJ_APP_PRIMITIVE)) != 0) {
		// FIXME: same question as for floats (but iirc it just packs on system V)
		for (std::size_t i = 0; i < size; i += 4) {
			decl += fmt::format("asDWORD _{}; ", i);
		}
	} else {
		log(*m_config,
		    *m_script_engine,
		    LogSeverity::ASEA_PERF_HINT,
		    "Type `{}` has unsupported layout for pass/return-by-value. Native call will fall back to VM.",
		    type_info.GetName());
		return {};
	}

	decl += fmt::format("}} {};\n", gen_name);
	emit_forward_declaration(state, gen_name, "{}", decl);
	return gen_name;
}

void BytecodeToC::emit_direct_script_call_ins(FnState& state, std::variant<ScriptCallByIdx, ScriptCallByExpr> call) {
	// TODO: figure out a way to inline callees. maybe we can find simple functions and trigger their generation in
	// a way that ensures they will be compiled? or we can just bring them into our module??

	bool will_emit_direct = m_config->experimental_fast_script_call && m_config->hack_ignore_suspend;

	std::string        fn_expr;
	asCScriptFunction* reference_fn;       // reference fn, only its signature is checked
	asCScriptFunction* known_fn = nullptr; // actual fn, null if unknown

	if (const auto* call_by_idx = std::get_if<ScriptCallByIdx>(&call); call_by_idx != nullptr) {
		std::string fn_raw_name = fmt::format("{}_scriptfn{}", m_c_symbol_prefix, call_by_idx->fn_idx);
		fn_expr                 = fmt::format("(asCScriptFunction*)&{}", fn_raw_name);
		known_fn = reference_fn = m_script_engine->scriptFunctions[call_by_idx->fn_idx];

		if (m_on_map_extern_callback) {
			m_on_map_extern_callback(fn_raw_name.c_str(), ExternScriptFunction{call_by_idx->fn_idx}, known_fn);
		}

		emit_forward_declaration(state, fn_raw_name, "extern char {}[];\n", fn_raw_name);
	} else if (auto* call_by_expr = std::get_if<ScriptCallByExpr>(&call); call_by_expr != nullptr) {
		fn_expr      = call_by_expr->expr;
		reference_fn = call_by_expr->fn_decl;
	} else {
		angelsea_assert(false);
	}

	if (will_emit_direct) {
		if (known_fn != nullptr) {
			emit(
			    "\t\tasea_prepare_script_stack(_regs, {FN}, base_pc + {INS_OFFSET}, sp, fp);\n",
			    fmt::arg("FN", fn_expr),
			    fmt::arg("BYTECODE", m_module_state.fn_bytecode_ptr),
			    fmt::arg("INS_OFFSET", state.ins.offset + state.ins.size())
			);
			bool emitted_fp_var = false;
			// setup stack with our knowledge
			for (asUINT n = known_fn->scriptData->variables.GetLength(); n-- > 0;) {
				asSScriptVariable* var = known_fn->scriptData->variables[n];

				// don't clear the function arguments
				if (var->stackOffset <= 0) {
					continue;
				}

				if (var->onHeap && (var->type.IsObject() || var->type.IsFuncdef())) {
					if (!emitted_fp_var) {
						emit("\t\tasDWORD* callee_fp = regs->fp;\n");
						emitted_fp_var = true;
					}

					if (m_config->c.human_readable) {
						emit("\t\t/* arg {} requires clearing @ stack pos {} */\n", n, -var->stackOffset);
					}

					emit("\t\t((asea_var*)(callee_fp + {}))->as_asPWORD = 0;\n", -var->stackOffset);
				}
			}
		} else {
			// if the function is not known, do the above stack logic dynamically in runtime
			emit(
			    "\t\tasea_prepare_script_stack_and_vars(_regs, {FN}, base_pc + {INS_OFFSET}, sp, fp);\n",
			    fmt::arg("FN", fn_expr),
			    fmt::arg("BYTECODE", m_module_state.fn_bytecode_ptr),
			    fmt::arg("INS_OFFSET", state.ins.offset + state.ins.size())
			);
		}

		if (known_fn == state.fn) {
			if (m_config->c.human_readable) {
				emit("\t\t/* recursive call */\n");
			}
			emit(
			    "\t\t{SELF}(_regs, 1);\n"
			    "\t\treturn;\n",
			    fmt::arg("SELF", m_module_state.fn_name)
			);
		} else {
			// look up JITFunction to branch into directly. if it doesn't exist that's fine; in both case we drop to
			// the vm right after
			emit(
			    "\t\tvoid* script_data = *(void**)((char*)({FN}) + {OFF_SCRIPTFN_SCRIPTDATA});\n"
			    "\t\tasea_jit_fn jit_fn = *(asea_jit_fn*)((char*)script_data + {OFF_SCRIPTDATA_JITFN});\n"
			    "\t\tif (jit_fn) {{ jit_fn(_regs, 1); return; }}\n"
			    "\t\treturn;\n",
			    fmt::arg("FN", fn_expr),
			    fmt::arg("OFF_SCRIPTFN_SCRIPTDATA", DIRECT_VALUE_IF_POSSIBLE(asea_offset_scriptfn_scriptdata)),
			    fmt::arg("OFF_SCRIPTDATA_JITFN", DIRECT_VALUE_IF_POSSIBLE(asea_offset_scriptdata_jitfunction))
			);
		}
	} else {
		// Call fallback: We initiate the call from JIT, and the rest of the JitEntry handler will branch into the
		// correct instruction.
		emit_save_sp(state);
		emit_save_pc(state, true);
		emit(
		    "\t\tasea_call_script_function(_regs, {FN});\n"
		    "\t\treturn;\n",
		    fmt::arg("FN", fn_expr)
		);
	}
}

void BytecodeToC::emit_system_call(FnState& state, SystemCall call) {
	if (m_config->c.human_readable) {
		emit(
		    "\t\t/* Attempt direct system call for `{}` */\n",
		    m_script_engine->scriptFunctions[call.fn_idx]->GetDeclaration(true, true, true)
		);
	}

	const auto emit_for_abi = [&](AbiMask abi) {
		if ((std::uint64_t(m_config->c.abi) & std::uint64_t(abi)) == 0) {
			emit("#error ABI not compiled in\n");
			return;
		}

		const auto result = emit_direct_system_call(state, call, abi);
		if (!result.ok) {
			// fallback approach to ensure the call always succeeds even if we cannot emit a direct call
			if (m_config->c.human_readable) {
				emit("\t\t/* Fallback to VM call: {} */\n", result.fail_reason);
			}

			if (!call.is_internal_call) {
				flush_stack_push_optimization(state);
			}

			// push the self pointer in the fallback case
			if (!call.is_internal_call && !call.object_pointer_override.empty()) {
				emit(
				    "\t\tsp = (asea_var*)((char*)sp - sizeof(asPWORD));\n"
				    "\t\tsp->as_ptr = {};\n",
				    call.object_pointer_override
				);
			}

			if (!call.is_internal_call) {
				emit_save_sp(state);
				emit_save_pc(state, true);
				emit(
				    "\t\tsp = (asea_var*)((asDWORD*)sp + asea_call_system_function(_regs, {FN}));\n"
				    "\t\tvalue_reg = regs->value;\n",
				    fmt::arg("FN", call.fn_idx)
				);

				// FIXME: doprocessuspend check wrt setting *script* exceptions correctness
			} else {
				// TODO: assert for method
				emit_save_sp(state);
				emit_save_pc(state, true);
				emit("\t\tasea_call_object_method(_regs, {}, {});\n", call.object_pointer_override, call.fn_idx);
			}
		}
	};

	// TODO: move this logic in its own function
	emit("#if defined(__linux__) && (defined(__GNUC__) || defined(__MIRC__)) && defined(__x86_64__)\n");
	emit_for_abi(AbiMask::LINUX_GCC_X86_64);
	emit("#elif defined(_WIN32) && (defined(_MSC_VER) || defined(ASEA_ABI_MSVC))\n"); // must precede mingw check
	emit_for_abi(AbiMask::WINDOWS_MSVC_X86_64);
	emit("#elif defined(_WIN32) && (defined(__GNUC__) || defined(__MIRC__)) && defined(__x86_64__)\n");
	emit_for_abi(AbiMask::WINDOWS_MINGW_X86_64);
	emit("#elif defined(__APPLE__) && defined(__x86_64__)\n");
	emit_for_abi(AbiMask::MACOS_X86_64);
	emit("#elif defined(__linux__) && (defined(__GNUC__) || defined(__MIRC__)) && defined(__aarch64__)\n");
	emit_for_abi(AbiMask::LINUX_GCC_AARCH64);
	emit("#elif defined(__APPLE__) && defined(__aarch64__)\n");
	emit_for_abi(AbiMask::MACOS_AARCH64);
	emit("#else\n");
	emit_for_abi(AbiMask::GENERIC);
	emit("#endif\n");
}

BytecodeToC::SystemCallEmitResult BytecodeToC::emit_direct_system_call(FnState& state, SystemCall call, AbiMask abi) {
	if (!m_config->hack_ignore_exceptions) {
		return {.ok = false, .fail_reason = "Direct system call failed: hack_ignore_exceptions == false"};
	}

	if (!m_config->hack_ignore_suspend) {
		return {.ok = false, .fail_reason = "Direct system call failed: hack_ignore_suspend == false"};
	}

	const std::string           fn_callable_symbol = fmt::format("{}_sysfnptr{}", m_c_symbol_prefix, call.fn_idx);
	const std::string           fn_desc_symbol     = fmt::format("{}_sysfn{}", m_c_symbol_prefix, call.fn_idx);
	asCScriptFunction&          script_fn          = *m_script_engine->scriptFunctions[call.fn_idx];
	asSSystemFunctionInterface& sys_fn             = *script_fn.sysFuncIntf;
	const internalCallConv      icc                = sys_fn.callConv;

	if (m_on_map_extern_callback) {
		m_on_map_extern_callback(fn_desc_symbol.c_str(), ExternScriptFunction{call.fn_idx}, &script_fn);
		m_on_map_extern_callback(
		    fn_callable_symbol.c_str(),
		    ExternSystemFunction{call.fn_idx},
		    std::bit_cast<void*>(sys_fn.func)
		);
	}

	if (icc == ICC_GENERIC_FUNC || icc == ICC_GENERIC_METHOD) {
		return emit_direct_system_call_generic(state, call, script_fn, fn_desc_symbol, fn_callable_symbol);
	}

	return emit_direct_system_call_native(state, call, script_fn, fn_desc_symbol, fn_callable_symbol, abi);
}

struct VirtualStack {
	std::int64_t dword_offset = 0, pword_offset = 0;
	std::size_t  real_stack_offset = 0;

	void take_dwords(std::size_t count) {
		dword_offset += count;
		real_stack_offset += count;
	}
	void take_pwords(std::size_t count) {
		pword_offset += count;
		real_stack_offset += count * AS_PTR_SIZE;
	}

	void inject_dwords(std::size_t count) { dword_offset -= count; }
	void inject_pwords(std::size_t count) { pword_offset -= count; }
};

BytecodeToC::SystemCallEmitResult BytecodeToC::emit_direct_system_call_native(
    FnState&           state,
    SystemCall         call,
    asCScriptFunction& fn,
    std::string_view   fn_desc_symbol,
    std::string_view   fn_callable_symbol,
    AbiMask            abi
) {
	// FIXME: this thing is an abomination and it haunts my dreams (frankly, almost literally)
	// i have no excuse for it and i keep postponing the inevitable. and yet it's 3am, and i'm still considering
	// adding an unordered map that tracks *yet another* thing and i fear that if i keep going clang will ultimately
	// gain consciousness just enough for it to remove itself from my drive

	if (!m_config->experimental_direct_native_call) {
		return {.ok = false, .fail_reason = "Direct native call failed: experimental_direct_native_call == false"};
	}

	asSSystemFunctionInterface& sys_fn = *fn.sysFuncIntf;

	if (sys_fn.isCompositeIndirect) {
		return {.ok = false, .fail_reason = "Direct native call failed: Cannot handle compositeIndirect yet"};
	}

	if (sys_fn.auxiliary != nullptr || sys_fn.callConv >= ICC_THISCALL_OBJLAST) {
		return {.ok = false, .fail_reason = "Direct native call failed: Cannot make sense of auxiliary functions yet"};
	}

	if (fn.returnType.IsFuncdef() && !fn.returnType.IsReference()) {
		return {.ok = false, .fail_reason = "Direct native call failed: Need to add tests for funcdef return"};
	}

	// TODO: don't use it since upstream AS has a TODO to remove it
	for (std::size_t i = 0; i < sys_fn.paramAutoHandles.GetLength(); ++i) {
		if (sys_fn.paramAutoHandles[i]) {
			return {.ok = false, .fail_reason = "Direct native call failed: Cannot handle auto handles in params yet"};
		}
	}

	if (sys_fn.returnAutoHandle) {
		return {.ok = false, .fail_reason = "Direct native call failed: Cannot handle auto handles in return yet"};
	}

	std::vector<std::string> struct_decls;

	const auto get_var_type = [&](const asCDataType& type) -> VarType {
		if (type.IsReference() || type.IsObjectHandle()) {
			return var_types::void_ptr;
		}

		if (type.IsFloatType()) {
			return var_types::f32;
		}
		if (type.IsDoubleType()) {
			return var_types::f64;
		}
		if (type.IsIntegerType() || type.IsUnsignedType() || type.IsBooleanType() || type.IsEnumType()) {
			return type.GetSizeInMemoryDWords() == 1 ? var_types::u32 : var_types::u64;
		}

		if (type.GetSizeInMemoryBytes() == 0) {
			return {"void", "void", 0};
		}

		std::string maybe_struct_decl = emit_dummy_struct_declaration(state, type);

		if (maybe_struct_decl.empty()) {
			return {};
		}

		struct_decls.push_back(std::move(maybe_struct_decl));

		return {std::string_view{struct_decls.back()}, {}, std::size_t(type.GetSizeInMemoryBytes())};
	};

	VarType return_type = {"void", {}, 0};

	if (!is_complex_passed_by_value(fn.returnType)) {
		return_type = get_var_type(fn.returnType);

		if (return_type.c.empty()) {
			return {.ok = false, .fail_reason = "Direct native call failed: Return type cannot be handled"};
		}
	}

	// FIXME: set m_callingsystemfunction when config requests

	switch (sys_fn.callConv) {
	case ICC_CDECL:
	case ICC_CDECL_OBJFIRST:
	case ICC_CDECL_OBJLAST:
	case ICC_VIRTUAL_THISCALL:
	case ICC_THISCALL:         break;
	default:                   return {.ok = false, .fail_reason = "Unsupported calling convention"};
	}

	// gather arguments to build C signature (and early fail on unsupported types)

	std::vector<std::pair<VarType, std::string>> args;
	std::unordered_map<int, std::size_t>         stack_offset_to_arg_id;

	VirtualStack virtual_stack;

	std::string obj_expr;
	std::string to_emit_before_call;
	std::string to_emit_after_call;
	std::string return_target_override;

	// TODO: abstract the stack pop logic elsewhere

	// treat it as "virtual" stack on top of the real stack so to speak
	std::vector<std::size_t>* push_offsets = nullptr;
	std::int64_t              push_offset_idx;

	if (auto it = state.fn_to_stack_push.find(state.ins.offset); it != state.fn_to_stack_push.end()) {
		push_offsets    = &it->second;
		push_offset_idx = std::int64_t(push_offsets->size()) - 1;
	}

	const auto virtual_stack_pop_expr = [&](VarType type) {
		if (push_offsets != nullptr && push_offset_idx >= 0) {
			const auto push_ins_offset = (*push_offsets)[push_offset_idx];
			const auto push_info       = state.stack_push_infos.at(push_ins_offset);

			std::string ret = fmt::format("push_tmp{ID}", fmt::arg("ID", push_ins_offset));
			--push_offset_idx;

			if (push_info.type == var_types::u32) {
				virtual_stack.inject_dwords(1);
			} else if (push_info.type == var_types::u64) {
				virtual_stack.inject_dwords(2);
			} else if (push_info.type == var_types::pword) {
				virtual_stack.inject_pwords(1);
			} else if (push_info.type == var_types::void_ptr) {
				virtual_stack.inject_pwords(1);
			} else {
				angelsea_assert(false);
			}

			// HORRIFYING for a layer of reasons
			// one being that it is still possible to fallback at this point and leave useless vars but w/e
			// also MIR miscompiles if we abuse the comma operator to do this e.g. `(asea_i2f_inst.i = 123,
			// asea_i2f_inst.f)` so instead we go through a new temporary variable. this in itself doesn't really
			// change anything, but it means we emit it before here
			//
			// TODO: it would be nice if the code on the push side knew about the type we're expecting on the
			// argument side. at the moment, MIR requires int-float bit casts (effectively what we do via unions) to
			// happen by a memory load and store instead of a register move (see
			// https://github.com/vnmakarov/mir/issues/293)
			if (type == var_types::f32) {
				to_emit_before_call += fmt::format(
				    "\t\tasea_i2f_inst.i = {};\n"
				    "\t\tfloat tmp_casted{} = asea_i2f_inst.f;\n",
				    ret,
				    push_ins_offset
				);
				return fmt::format("tmp_casted{}", push_ins_offset);
			}
			if (type == var_types::f64) {
				to_emit_before_call += fmt::format(
				    "\t\tasea_i2f64_inst.i = {};\n"
				    "\t\tdouble tmp_casted{} = asea_i2f64_inst.f;\n",
				    ret,
				    push_ins_offset
				);
				return fmt::format("tmp_casted{}", push_ins_offset);
			}
			return fmt::format("({}){}", type.c, ret);
		}

		return fmt::format(
		    "((asea_var*)((char*)sp + {DWORDS}*sizeof(asDWORD) + {PWORDS}*sizeof(asPWORD)))->as_{ACCESSOR}",
		    fmt::arg("DWORDS", virtual_stack.dword_offset),
		    fmt::arg("PWORDS", virtual_stack.pword_offset),
		    fmt::arg("ACCESSOR", type.var_accessor)
		);
	};

	const auto push_abi_argument   = [&](VarType type, std::string expr) { args.emplace_back(type, std::move(expr)); };
	const auto push_stack_argument = [&](VarType type) { push_abi_argument(type, virtual_stack_pop_expr(type)); };

	const bool is_thiscall_objfirst = sys_fn.callConv == ICC_THISCALL || sys_fn.callConv == ICC_VIRTUAL_THISCALL
	    /*|| sys_fn.callConv == ICC_VIRTUAL_THISCALL_OBJFIRST*/;
	const bool is_cdecl_objfirst = sys_fn.callConv == ICC_CDECL_OBJFIRST;

	if (sys_fn.callConv >= ICC_THISCALL) {
		// always load `this` from the first position in the stack
		if (call.object_pointer_override.empty()) {
			obj_expr = virtual_stack_pop_expr(var_types::void_ptr);
			virtual_stack.take_pwords(1);
		}
	}

	if (is_complex_passed_by_value(fn.returnType)) {
		to_emit_before_call += fmt::format("\t\tvoid* ret_ptr = {};\n", virtual_stack_pop_expr(var_types::void_ptr));
		virtual_stack.take_pwords(1);
	} else if (fn.DoesReturnOnStack()) {
		return_target_override = fmt::format(
		    "*({TYPE}*){EXPR}",
		    fmt::arg("TYPE", return_type.c),
		    fmt::arg("EXPR", virtual_stack_pop_expr(var_types::void_ptr))
		);
		virtual_stack.take_pwords(1);
	}

	// Handle complex return logic depending on active C++ ABI.
	// For the C++ thiscall ABI, gcc always puts the return pointer as the first ABI parameter.
	// MSVC puts it after the object parameter.
	// CDECL_OBJFIRST is always after the return pointer since this is at application level.
	if (abi == AbiMask::LINUX_GCC_X86_64 || abi == AbiMask::WINDOWS_MINGW_X86_64) {
		if (is_complex_passed_by_value(fn.returnType)) {
			push_abi_argument(var_types::void_ptr, "ret_ptr");
		}

		if (is_thiscall_objfirst) {
			push_abi_argument(var_types::void_ptr, "obj");
		}
	} else if (abi == AbiMask::WINDOWS_MSVC_X86_64) {
		if (is_thiscall_objfirst) {
			push_abi_argument(var_types::void_ptr, "obj");
		}

		if (is_complex_passed_by_value(fn.returnType)) {
			push_abi_argument(var_types::void_ptr, "ret_ptr");
		}
	} else {
		if (is_complex_passed_by_value(fn.returnType)) {
			return {.ok = false, .fail_reason = "Complex return types not implemented for this ABI"};
		}

		if (is_thiscall_objfirst) {
			push_abi_argument(var_types::void_ptr, "obj");
		}
	}

	if (is_cdecl_objfirst) {
		push_abi_argument(var_types::void_ptr, "obj");
	}

	for (std::size_t i = 0; i < fn.parameterTypes.GetLength(); ++i) {
		const auto& param_type = fn.parameterTypes[i];

		stack_offset_to_arg_id.emplace(virtual_stack.real_stack_offset, args.size());

		if (param_type.GetTokenType() == ttQuestion) {
			return {.ok = false, .fail_reason = "Direct native call failed: Cannot handle variable arguments yet"};
		} else if (param_type.IsReference() || param_type.IsObjectHandle()) {
			push_stack_argument(var_types::void_ptr);
			virtual_stack.take_pwords(1);
		} else if (param_type.IsPrimitive()) {
			push_stack_argument(get_var_type(param_type));
			virtual_stack.take_dwords(param_type.GetSizeOnStackDWords());
		} else if (is_complex_passed_by_value(param_type)) {
			push_stack_argument(var_types::void_ptr);
			virtual_stack.take_pwords(1);
		} else {
			// we have a pointer on stack to a pass-by-value argument. make a dummy type (when possible) to use as
			// an argument for that function, and dereference the stack pointer to get the argument
			VarType     arg_type = get_var_type(param_type);
			std::string arg_ptr  = fmt::format(
                "({TYPE}*){VOID_PTR}",
                fmt::arg("TYPE", arg_type.c),
                fmt::arg("VOID_PTR", virtual_stack_pop_expr(var_types::void_ptr))
            );
			push_abi_argument(arg_type, fmt::format("*{}", arg_ptr));

			// TODO: store to tmp var to avoid reloading from stack again
			to_emit_after_call += fmt::format("\t\tasea_free({});\n", arg_ptr);
			virtual_stack.take_pwords(1);
		}
	}

	if (sys_fn.callConv == ICC_CDECL_OBJLAST) {
		push_abi_argument(var_types::void_ptr, "obj");
	}

	// can start emit()s from this point on

	emit("{}", to_emit_before_call);

	// restore stack pushes that were *not* for us
	if (push_offsets != nullptr && push_offset_idx >= 0) {
		if (m_config->c.human_readable) {
			emit("\t\t/* Stack elision optimization caught more pushes than intended; pushing them */\n");
		}

		for (std::size_t i = 0; i <= std::size_t(push_offset_idx); ++i) {
			const auto push_ins_offset = (*push_offsets)[i];
			const auto push_info       = state.stack_push_infos.at(push_ins_offset);
			emit_stack_push(state, fmt::format("push_tmp{}", push_ins_offset), push_info.type);
		}

		if (m_config->c.human_readable) {
			emit("\t\t/* Stack elision flush done */\n");
		}
	}

	if (sys_fn.callConv >= ICC_THISCALL) {
		if (call.object_pointer_override.empty()) {
			emit(
			    "\t\tvoid *obj = {OBJ_EXPR};\n"
			    "\t\tif (obj == 0) {{ {ERR_NULL_HANDLER} }}\n",
			    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL)),
			    fmt::arg("OBJ_EXPR", obj_expr)
			);
		} else {
			emit("\t\tvoid *obj = {};\n", call.object_pointer_override);
		}
	}

	if (sys_fn.baseOffset > 0) {
		switch (abi) {
		case AbiMask::LINUX_GCC_X86_64:
		case AbiMask::WINDOWS_MSVC_X86_64:
		case AbiMask::WINDOWS_MINGW_X86_64:
		case AbiMask::MACOS_X86_64:         {
			emit("\t\tobj = (char*)obj + {BASE_OFFSET};\n", fmt::arg("BASE_OFFSET", sys_fn.baseOffset));
			break;
		}
		case AbiMask::LINUX_GCC_AARCH64:
		case AbiMask::MACOS_AARCH64:     {
			emit("\t\tobj = (char*)obj + ({BASE_OFFSET} >> 1);\n", fmt::arg("BASE_OFFSET", sys_fn.baseOffset));
			break;
		}
		case AbiMask::GENERIC:
		default:
			return {.ok = false, .fail_reason = "baseOffset (from multiple inheritance) is not supported on this ABI."};
		}
	}

	if (!m_config->hack_ignore_context_inspect) {
		emit_save_sp(state);
		emit_save_pc(state, true);
	} else {
		// write stack pointer in case the syscall causes a nested script call; otherwise our stack may get stomped
		// TODO: this may be possible to elide if we detect that the sp hasn't gone downwards since
		emit("\t\tregs->sp = sp;\n");
	}

	std::string final_callable_name;

	std::vector<std::string> formatted_arg_types(args.size());
	for (std::size_t i = 0; i < formatted_arg_types.size(); ++i) {
		formatted_arg_types[i] = args[i].first.c;
	}

	if (sys_fn.callConv == ICC_VIRTUAL_THISCALL || sys_fn.callConv == ICC_VIRTUAL_THISCALL_OBJFIRST
	    || sys_fn.callConv == ICC_VIRTUAL_THISCALL_OBJLAST) {
		// dereference pointer via the vtable. this is janky! we are in C, so we essentially have to emulate the C++
		// ABI here. TODO: option to disable virtual calls specifically?

		emit_forward_declaration(state, std::string(fn_callable_symbol), "extern char {}[];\n", fn_callable_symbol);

		emit(
		    "typedef {RETTYPE} (*virtfn)({ARGTYPES});\n",
		    fmt::arg("RETTYPE", return_type.c),
		    fmt::arg("ARGTYPES", fmt::join(formatted_arg_types, ","))
		);

		switch (abi) {
		case AbiMask::LINUX_GCC_X86_64:
		case AbiMask::WINDOWS_MINGW_X86_64:
		case AbiMask::MACOS_X86_64:
		case AbiMask::LINUX_GCC_AARCH64:
		case AbiMask::MACOS_AARCH64:        {
			emit(
			    "\t\tvirtfn* vftable = *(virtfn**)obj;\n"
			    "\t\tvirtfn fn = vftable[(asPWORD)&{FNCALLABLE} / sizeof(void*)];\n",
			    fmt::arg("FNCALLABLE", fn_callable_symbol)
			);
			break;
		}
		case AbiMask::WINDOWS_MSVC_X86_64: {
			emit(
			    "\t\tvirtfn* vftable = *(virtfn**)obj;\n"
			    "\t\tvirtfn fn = vftable[(asPWORD)&{FNCALLABLE} >> 2];\n",
			    fmt::arg("FNCALLABLE", fn_callable_symbol)
			);
			break;
		}
		case AbiMask::GENERIC:
		default:               return {.ok = false, .fail_reason = "Virtual functions are not supported on this ABI."};
		}

		final_callable_name = "fn";
	} else {
		emit_forward_declaration(
		    state,
		    std::string(fn_callable_symbol),
		    "extern {RETTYPE} {FNCALLABLE}({ARGTYPES});\n",
		    fmt::arg("RETTYPE", return_type.c),
		    fmt::arg("FNCALLABLE", fn_callable_symbol),
		    fmt::arg("ARGTYPES", fmt::join(formatted_arg_types, ","))
		);
		final_callable_name = fn_callable_symbol;
	}

	// perform the actual call. the expression to perform the call is always the same but the surrounding call to
	// figure out where to store the return value differs.
	std::string call_expression = fmt::format("{FN}(", fmt::arg("FN", final_callable_name));
	for (auto it = args.begin(); it != args.end(); ++it) {
		const auto& expr = it->second;
		call_expression += fmt::format("\n\t\t\t{}", expr);
		if (std::next(it) != args.end()) {
			call_expression += ',';
		}
	}
	call_expression += ')';

	if (!return_target_override.empty()) {
		emit(
		    "\t\t{TARGET} = {CALL_EXPR};\n",
		    fmt::arg("TARGET", return_target_override),
		    fmt::arg("CALL_EXPR", call_expression)
		);
	} else if (fn.returnType.IsObjectHandle() && !fn.returnType.IsReference()) {
		// FIXME: set objectType
		emit("\t\tregs->obj = {};\n", call_expression);
		// TODO: auto handles
		angelsea_assert(!sys_fn.returnAutoHandle);
	} else if ((fn.returnType.IsObject() || fn.returnType.IsFuncdef()) && !fn.returnType.IsReference()) {
		if (return_type.c == "void*") {
			emit("\t\tvalue_reg = (asPWORD){};\n", call_expression);
		} else {
			// return-by-value: the return value is passed by pointer as part of the argument list
			emit("\t\t{};\n", call_expression);
		}
	} else if (return_type.c != "void") {
		if (return_type.c == "void*") {
			emit("\t\tvalue_reg = (asPWORD){};\n", call_expression);
		} else if (fn.returnType.IsUnsignedType() || fn.returnType.IsIntegerType() || fn.returnType.IsBooleanType()
		           || fn.returnType.IsEnumType()) {
			// straight copy, bypass union that might not be optimized away by MIR
			emit("\t\tvalue_reg = {};\n", call_expression);
		} else {
			// must do a proper bit cast via an union in case of floating-point types
			emit(
			    "\t\tasea_var ret_conv;\n"
			    "\t\tret_conv.as_{RETTYPE} = {CALL_EXPR};\n"
			    "\t\tvalue_reg = ret_conv.as_asQWORD;\n",
			    fmt::arg("RETTYPE", return_type.c),
			    fmt::arg("CALL_EXPR", call_expression)
			);
		}
	} else {
		emit("\t\t{};\n", call_expression);
	}

	emit("{}", to_emit_after_call);

	// TODO: move this out and reuse for generic convention. also suspiciously similar to asBC_FREE in shape, any
	// reuse possible?
	if (sys_fn.cleanArgs.GetLength() > 0) {
		auto& clean_args        = fn.sysFuncIntf->cleanArgs;
		int   clean_base_offset = 0;

		// the clean base offsets are offset by those... should figure out a cleaner way to do this, especially as
		// upstream AS may modify this behavior
		if (fn.DoesReturnOnStack()) {
			clean_base_offset += AS_PTR_SIZE;
		}

		if (sys_fn.callConv >= ICC_THISCALL && sys_fn.auxiliary == nullptr) {
			clean_base_offset += AS_PTR_SIZE;
		}

		for (std::size_t i = 0; i < clean_args.GetLength(); ++i) {
			const std::size_t arg_id = stack_offset_to_arg_id.at(clean_args[i].off + clean_base_offset);
			emit(
			    "\t\t{{\n"
			    "\t\tvoid* clean = {};\n",
			    args[arg_id].second
			);
			if (clean_args[i].op == 0) {
				emit("\t\tif (clean) {{\n");
				emit_system_call(
				    state,
				    {.fn_idx                  = clean_args[i].ot->beh.release,
				     .object_pointer_override = "clean",
				     .is_internal_call        = true}
				);
				emit(
				    "\t\tclean{} = 0;\n"
				    "\t\t}}\n",
				    i
				);
			} else {
				if (clean_args[i].op == 2) {
					emit_system_call(
					    state,
					    {.fn_idx                  = clean_args[i].ot->beh.destruct,
					     .object_pointer_override = "clean",
					     .is_internal_call        = true}
					);
				}

				emit(
				    "\t\tasea_free(clean);\n"
				    "\t\t}}\n"
				);
			}
		}
	}

	// pop stack arguments (at least the ones that weren't in the "virtual" stack elision stack)
	if (!call.is_internal_call && (virtual_stack.dword_offset > 0 || virtual_stack.pword_offset > 0)) {
		emit(
		    "\t\tsp = (asea_var*)((asDWORD*)sp + {STACK_DWORDS} + {STACK_PWORDS} * (sizeof(asPWORD) / 4));\n",
		    fmt::arg("STACK_DWORDS", virtual_stack.dword_offset),
		    fmt::arg("STACK_PWORDS", virtual_stack.pword_offset)
		);
	}

	return {.ok = true, .fail_reason = {}};
}

BytecodeToC::SystemCallEmitResult BytecodeToC::emit_direct_system_call_generic(
    FnState&           state,
    SystemCall         call,
    asCScriptFunction& fn,
    std::string_view   fn_desc_symbol,
    std::string_view   fn_callable_symbol
) {
	if (!m_config->experimental_direct_generic_call) {
		return {.ok = false, .fail_reason = "Direct generic call failed: experimental_direct_generic_call == false"};
	}

	asSSystemFunctionInterface& sys_fn = *fn.sysFuncIntf;

	const internalCallConv icc = sys_fn.callConv;

	if (!call.is_internal_call) {
		if (fn.IsVariadic()) {
			// TODO: variadics are a bit annoying to support; certainly viable but they're so rare that other than
			// full AOT i don't see the point to support them
			return {.ok = false, .fail_reason = "Direct generic call failed: Variadics not supported yet"};
		}

		if (sys_fn.returnAutoHandle && m_script_engine->ep.genericCallMode == 1) {
			return {.ok = false, .fail_reason = "Direct generic call failed: Auto handles not supported yet"};
		}
	}

	if (!m_config->hack_ignore_context_inspect) {
		emit_save_sp(state);
		emit_save_pc(state, true);
	} else {
		// write stack pointer in case the syscall causes a nested script call; otherwise our stack may get stomped
		// TODO: this may be possible to elide if we detect that the sp hasn't gone downwards since
		emit("\t\tregs->sp = sp;\n");
	}

	// generic ABI requires arguments etc. to be on stack
	flush_stack_push_optimization(state);

	emit(
	    "\t\tasDWORD* args = &sp->as_asDWORD;\n"
	    "\t\tint pop_size = {INIT_POP_SIZE};\n",
	    fmt::arg("INIT_POP_SIZE", sys_fn.paramSize)
	);

	// TODO: check which of those could skip initialization if there are cases where the asCGeneric methods will
	// never read them

	// FIXME: optional suspend support -- also doProcessSuspend also includes setting exceptions on the script
	// context! also check this for script to script calls

	// FIXME: set m_callingSystemFunction -- also relevant to the above?

	if (icc == ICC_GENERIC_METHOD) {
		if (!call.object_pointer_override.empty()) {
			emit("\t\tg.currentObject = {};\n", call.object_pointer_override);
		} else {
			emit(
			    "\t\tpop_size += sizeof(asPWORD) / 4;\n"
			    "\t\targs += sizeof(asPWORD) / 4;\n"
			    "\t\tg.currentObject = sp->as_ptr;\n"
			    "\t\tif (g.currentObject == 0) {{ {ERR_NULL_HANDLER} }}\n",
			    fmt::arg("ERR_NULL_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_NULL))
			);
		}
	}

	if (!call.is_internal_call) {
		if (fn.DoesReturnOnStack()) {
			emit(
			    "\t\tpop_size += sizeof(asPWORD) / 4;\n"
			    "\t\targs += sizeof(asPWORD) / 4;\n"
			);
		}
		emit("\t\tg.stackPointer = args;\n"); // TODO: don't write if the stack never needs to be accessed
	}

	emit(
	    "\t\textern void {FNCALLABLE}(asea_generic*);\n"
	    "\t\textern void {FNDESC};\n"
	    "\t\tg.sysFunction = &{FNDESC};\n",
	    fmt::arg("FNDESC", fn_desc_symbol),
	    fmt::arg("FNCALLABLE", fn_callable_symbol)
	);

	if (!m_config->hack_generic_assume_callee_correctness) {
		emit(
		    "\t\tg.objectRegister = 0;\n"
		    "\t\tg.returnVal = 0;\n"
		);
	}

	emit("\t\t{FNCALLABLE}(&g);\n", fmt::arg("FNCALLABLE", fn_callable_symbol));

	if (!call.is_internal_call) {
		// TODO: we can probably statically tell which regs need to be written to and which don't
		emit("\t\tsp = (asea_var*)((asDWORD*)sp + pop_size);\n");

		bool uses_object_register
		    = (fn.returnType.IsObject() || fn.returnType.IsFuncdef()) && !fn.returnType.IsReference();

		if (uses_object_register) {
			asITypeInfo* ret_type_info = fn.returnType.GetTypeInfo();
			angelsea_assert(ret_type_info != nullptr);

			const auto ret_type_info_expr = emit_type_info_lookup(state, *ret_type_info);
			emit(
			    "\t\tregs->obj = g.objectRegister;\n"
			    "\t\tregs->obj_type = (asITypeInfo*){RETTYPEINFO};\n",
			    fmt::arg("RETTYPEINFO", ret_type_info_expr)
			);
		} else {
			emit("\t\tvalue_reg = g.returnVal;\n");
		}

		// TODO: JIT compile this, but it probably isn't *that* important since frees are likely to be moderately
		// expensive compared to a few branches either way
		if (sys_fn.cleanArgs.GetLength() > 0) {
			emit("\t\tasea_clean_args(_regs, &{FNDESC}, args);\n", fmt::arg("FNDESC", fn_desc_symbol));
		}
	}

	return {.ok = true, .fail_reason = {}};
}

void BytecodeToC::emit_stack_push_ins(FnState& state, const bcins::StackPush& push) {
	const VarType type = make_local_from_operand(state, "v", push.value);
	if (state.stack_push_infos.contains(state.ins.offset)) {
		emit("\t\tpush_tmp{ID} = v;\n", fmt::arg("ID", state.ins.offset));
	} else {
		emit_stack_push(state, "v", type);
	}
}

void BytecodeToC::flush_stack_push_optimization(FnState& state) {
	if (m_config->c.human_readable) {
		emit(
		    "\t\t/* Stack elision optimization must be cancelled because we're falling back to VM; pushing back "
		    "the "
		    "elided pushes */\n"
		);
	}

	// flush pushes for calls originating from scripts
	if (auto it = state.fn_to_stack_push.find(state.ins.offset); it != state.fn_to_stack_push.end()) {
		for (auto push_off : it->second) {
			emit_stack_push(state, fmt::format("push_tmp{}", push_off), state.stack_push_infos.at(push_off).type);
		}
	}

	if (m_config->c.human_readable) {
		emit("\t\t/* Stack elision flush done */\n\n");
	}
}

void BytecodeToC::emit_assign_ins(FnState& state, std::string_view dst, std::string_view src) {
	emit("\t\t{DST} = {SRC};\n", fmt::arg("DST", dst), fmt::arg("SRC", src));
}

void BytecodeToC::emit_stack_push(FnState& state, std::string_view expr, VarType type) {
	if (type == var_types::pword || type == var_types::void_ptr) {
		emit("\t\tsp = (asea_var*)((char*)sp - sizeof(asPWORD));\n");
	} else {
		emit("\t\tsp = (asea_var*)((char*)sp - {});\n", type.size);
	}

	emit("\t\tsp->as_{TYPE} = {EXPR};\n", fmt::arg("TYPE", type.var_accessor), fmt::arg("EXPR", expr));
}

void BytecodeToC::emit_cond_branch(FnState& state, std::string_view expr, std::size_t target_offset) {
	if (m_config->c.use_builtin_expect) {
		emit(
		    "\t\tif (__builtin_expect({TEST}, {EXPECTED_BRANCH_VALUE})) {{\n",
		    fmt::arg("TEST", expr),
		    fmt::arg("EXPECTED_BRANCH_VALUE", target_offset < state.ins.offset ? 1 : 0)
		);
	} else {
		emit("\t\tif ({TEST}) {{\n", fmt::arg("TEST", expr));
	}
	emit(
	    "\t\t\tgoto bc{BRANCH_TARGET};\n"
	    "\t\t}}\n",
	    fmt::arg("BRANCH_TARGET", target_offset)
	);
}

void BytecodeToC::emit_compare(FnState& state, const bcins::Compare& compare) {
	make_local_from_operand(state, "lhs", compare.lhs);
	make_local_from_operand(state, "rhs", compare.rhs);
	emit("\t\tvalue_reg = (lhs > rhs) - (lhs < rhs);\n");
}

void BytecodeToC::emit_test_ins(FnState& state, std::string_view op_with_rhs_0) {
	emit(
	    "\t\tasINT32 value = (asINT32)value_reg;\n"
	    "\t\tvalue_reg = (value {OP} 0) ? 1 : 0;\n",
	    fmt::arg("OP", op_with_rhs_0)
	);
}

void BytecodeToC::emit_prefixop_valuereg_ins(FnState& state, std::string_view op, VarType type) {
	emit("\t\t{OP}((asea_var*)value_reg)->as_{TYPE};\n", fmt::arg("OP", op), fmt::arg("TYPE", type.c));
}

void BytecodeToC::emit_unop_var_inplace_ins(FnState& state, std::string_view op, VarType type) {
	InsRef& ins = state.ins;
	emit("\t\t{VAR} = {OP} {VAR};\n", fmt::arg("OP", op), fmt::arg("VAR", frame_var(ins.sword0(), type)));
}

void BytecodeToC::emit_binop_var_var_ins(FnState& state, std::string_view op, VarType lhs, VarType rhs, VarType dst) {
	InsRef& ins = state.ins;
	emit(
	    "\t\t{DST} = {LHS} {OP} {RHS};\n",
	    fmt::arg("OP", op),
	    fmt::arg("DST", frame_var(ins.sword0(), dst)),
	    fmt::arg("LHS", frame_var(ins.sword1(), lhs)),
	    fmt::arg("RHS", frame_var(ins.sword2(), rhs))
	);
}

void BytecodeToC::emit_binop_var_imm_ins(
    FnState&         state,
    std::string_view op,
    VarType          lhs,
    std::string_view rhs_expr,
    VarType          dst
) {
	InsRef& ins = state.ins;
	emit(
	    "\t\t{DST} = {LHS} {OP} {RHS};\n",
	    fmt::arg("OP", op),
	    fmt::arg("DST", frame_var(ins.sword0(), dst)),
	    fmt::arg("LHS", frame_var(ins.sword1(), lhs)),
	    fmt::arg("RHS", rhs_expr)
	);
}

void BytecodeToC::emit_divmod_var_float_ins(FnState& state, std::string_view op, VarType type) {
	InsRef& ins = state.ins;
	emit(
	    "\t\t{TYPE} lhs = {LHS};\n"
	    "\t\t{TYPE} divider = {RHS};\n"
	    "\t\tif (divider == 0) {{ {ERR_DIVIDE_BY_ZERO_HANDLER} }}\n"
	    "\t\t{DST} = {OP}(lhs, divider);\n",
	    fmt::arg("ERR_DIVIDE_BY_ZERO_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_DIVIDE_BY_ZERO)),
	    fmt::arg("TYPE", type.c),
	    fmt::arg("DST", frame_var(ins.sword0(), type)),
	    fmt::arg("LHS", frame_var(ins.sword1(), type)),
	    fmt::arg("RHS", frame_var(ins.sword2(), type)),
	    fmt::arg("OP", op)
	);
}

void BytecodeToC::emit_divmod_var_int_ins(
    FnState&         state,
    std::string_view op,
    std::uint64_t    lhs_overflow_value,
    VarType          type
) {
	InsRef& ins = state.ins;
	emit(
	    "\t\t{TYPE} lhs = {LHS};\n"
	    "\t\t{TYPE} divider = {RHS};\n"
	    "\t\tif (divider == 0) {{ {ERR_DIVIDE_BY_ZERO_HANDLER}  }}\n"
	    "\t\tif (divider == -1 && lhs == ({TYPE}){LHS_OVERFLOW}) {{ {ERR_DIVIDE_OVERFLOW_HANDLER} }}\n"
	    "\t\t{DST} = lhs {OP} divider;\n",
	    fmt::arg("ERR_DIVIDE_BY_ZERO_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_DIVIDE_BY_ZERO)),
	    fmt::arg("ERR_DIVIDE_OVERFLOW_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_DIVIDE_OVERFLOW)),
	    fmt::arg("TYPE", type.c),
	    fmt::arg("DST", frame_var(ins.sword0(), type)),
	    fmt::arg("LHS", frame_var(ins.sword1(), type)),
	    fmt::arg("RHS", frame_var(ins.sword2(), type)),
	    fmt::arg("SWORD2", ins.sword2()),
	    fmt::arg("OP", op),
	    fmt::arg("LHS_OVERFLOW", lhs_overflow_value)
	);
}

void BytecodeToC::emit_divmod_var_unsigned_ins(FnState& state, std::string_view op, VarType type) {
	InsRef& ins = state.ins;
	emit(
	    "\t\t{TYPE} divider = {RHS};\n"
	    "\t\tif (divider == 0) {{ {ERR_DIVIDE_BY_ZERO_HANDLER}  }}\n"
	    "\t\t{DST} = {LHS} {OP} divider;\n",
	    fmt::arg("ERR_DIVIDE_BY_ZERO_HANDLER", jump_to_error_handler_code(state, ErrorHandler::ERR_DIVIDE_BY_ZERO)),
	    fmt::arg("TYPE", type.c),
	    fmt::arg("DST", frame_var(ins.sword0(), type)),
	    fmt::arg("LHS", frame_var(ins.sword1(), type)),
	    fmt::arg("RHS", frame_var(ins.sword2(), type)),
	    fmt::arg("OP", op)
	);
}

std::string BytecodeToC::frame_ptr(std::string_view expr) {
	return fmt::format("((asea_var*)((asDWORD*)fp - {}))", expr);
}

std::string BytecodeToC::frame_ptr(int offset) {
	if (offset == 0) {
		return "fp";
	}
	return frame_ptr(std::to_string(offset));
}

std::string BytecodeToC::frame_var(std::string_view expr, VarType type) {
	return fmt::format("((asea_var*)((asDWORD*)fp - {}))->as_{}", expr, type.c);
}

std::string BytecodeToC::frame_var(int offset, VarType type) {
	if (offset == 0) {
		return fmt::format("fp->as_{}", type.c);
	}
	return frame_var(std::to_string(offset), type);
}

std::string BytecodeToC::stack_var(int offset, VarType type) {
	return fmt::format("((asea_var*)((asDWORD*)sp + {}))->as_{}", fmt::to_string(offset), type.c);
}

} // namespace angelsea::detail