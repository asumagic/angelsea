Randomness seeded to: 2426415663
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231320712 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231440328 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231559944 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231683592 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231803208 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231926952 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232046568 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232158024 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232277640 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232401288 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232520904 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232644648 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232764264 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232617576 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232995336 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233114952 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233238600 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233358216 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)1;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689202047582207 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073709551614;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDi64 4 2 6 */
	bc19: {
		asINT64 lhs = ASEA_FRAME_VAR(2).as_asINT64;
		asINT64 rhs = ASEA_FRAME_VAR(6).as_asINT64;
		ASEA_FRAME_VAR(4).as_asINT64 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)20;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SUBi64 4 2 6 */
	bc19: {
		asINT64 lhs = ASEA_FRAME_VAR(2).as_asINT64;
		asINT64 rhs = ASEA_FRAME_VAR(6).as_asINT64;
		ASEA_FRAME_VAR(4).as_asINT64 = lhs - rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689202047582207 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073709551611;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MULi64 4 2 6 */
	bc19: {
		asINT64 lhs = ASEA_FRAME_VAR(2).as_asINT64;
		asINT64 rhs = ASEA_FRAME_VAR(6).as_asINT64;
		ASEA_FRAME_VAR(4).as_asINT64 = lhs * rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689202047582207 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073709551614;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DIVi64 4 2 6 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)7;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MODi64 4 2 6 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: NEGi64 4 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 2 */
	bc14: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc++;
	}
	/* bytecode: INCi64 */
	bc15: {
		++ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: RDR8 4 */
	bc16: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 4 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 2 */
	bc14: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc++;
	}
	/* bytecode: DECi64 */
	bc15: {
		--ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: RDR8 4 */
	bc16: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 4 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1098907648 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1098907648;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234056040 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1097859072 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234162600 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1096810496 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1096810496;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234273288 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1098907648 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1098907648;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234379848 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1097859072 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234478248 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1096810496 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1096810496;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234584808 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1098907648 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1098907648;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234691368 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1097859072 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234801960 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1096810496 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1096810496;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234908520 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1098907648 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1098907648;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235019208 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1097859072 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235125768 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1096810496 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1096810496;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235232328 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1098907648 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1098907648;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235330728 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1097859072 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235437288 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1097859072 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1097859072;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1096810496 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1096810496;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235547880 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPf 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/functions.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/functions.as:10:1: int calc(int64 a, int b) */
void asea_jit117_module_scripts_2F_functions_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc22;
	case 4: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 2 563645738123264 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: MULi64 2 0 2 */
	bc9: {
		asINT64 lhs = ASEA_FRAME_VAR(0).as_asINT64;
		asINT64 rhs = ASEA_FRAME_VAR(2).as_asINT64;
		ASEA_FRAME_VAR(2).as_asINT64 = lhs * rhs;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV8 0 2 */
	bc11: {
		ASEA_FRAME_VAR(0).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 2 0 */
	bc16: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(0).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 4 2 */
	bc18: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 4 */
	bc20: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(4).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 3 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MULi 3 3 -2 */
	bc25: {
		asINT32 lhs = ASEA_FRAME_VAR(3).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(-2).as_asINT32;
		ASEA_FRAME_VAR(3).as_asINT32 = lhs * rhs;
		l_bc += 2;
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoR4 3 */
	bc30: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc++;
	}
	/* bytecode: RET 3 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/functions.as:5:1: void main() */
void asea_jit116_module_scripts_2F_functions_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc22;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 100 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 100;
		l_bc += 2;
	}
	/* bytecode: PshC8 10 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = 10;
		l_bc += 3;
	}
	/* bytecode: CALL calc # int calc(int64 a, int b) */
	bc11: {
		extern char asea_script_fn117;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn117);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 4 */
	bc16: {
		ASEA_FRAME_VAR(4).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 6 4 */
	bc17: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(4).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/fib.as:3:1: int fib(int n) */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc28;
	case 5: goto bc38;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 0 2 */
	bc6: {
		int i1 = ASEA_FRAME_VAR(0).as_asINT32;
		int i2 = 2;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JNS 9 */
	bc8: {
		if( regs->valueRegister.as_asINT64 >= 0 ) {
			l_bc += 11;
			goto bc19;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoR4 0 */
	bc16: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(0).as_asDWORD;
		l_bc++;
	}
	/* bytecode: JMP 26 */
	bc17: {
		l_bc += 28;
		goto bc45;
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SUBIi 1 0 1 */
	bc22: {
		asINT32 lhs = ASEA_FRAME_VAR(0).as_asINT32;
		ASEA_FRAME_VAR(1).as_asINT32 = lhs - (1);
		l_bc += 3;
	}
	/* bytecode: PshV4 1 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL fib # int fib(int n) */
	bc26: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 2 */
	bc31: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBIi 1 0 2 */
	bc32: {
		asINT32 lhs = ASEA_FRAME_VAR(0).as_asINT32;
		ASEA_FRAME_VAR(1).as_asINT32 = lhs - (2);
		l_bc += 3;
	}
	/* bytecode: PshV4 1 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL fib # int fib(int n) */
	bc36: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 3 */
	bc41: {
		ASEA_FRAME_VAR(3).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDi 1 2 3 */
	bc42: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(3).as_asINT32;
		ASEA_FRAME_VAR(1).as_asINT32 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: CpyVtoR4 1 */
	bc44: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: RET 1 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/globals.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/globals.as:8:1: void assign_read() */
void asea_jit116_module_scripts_2F_globals_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc28;
	case 5: goto bc38;
	case 6: goto bc51;
	case 7: goto bc67;
	case 8: goto bc81;
	case 9: goto bc94;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 123 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: LDG 137073828823232 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 123 */
	bc15: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: LDG 137073828823408 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetG4 137073828823584 123 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 412316860416 */
	bc31: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)123;
		l_bc += 3;
	}
	/* bytecode: LDG 137073828823760 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDG 137073828823232 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc44: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc45: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc46: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc48: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc51: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc54: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDG 137073828823408 */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc60: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc61: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc62: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc64: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc67: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc70: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyGtoV4 1 845056290356394 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 3 1 */
	bc76: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc78: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc81: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc84: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDG 137073828823760 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc90: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc91: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc94: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc97: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $fact() */
void asea_jit125_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032713216 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # int[]@ int[]::array(int&in) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $fact(uint length) */
void asea_jit126_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032713216 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # int[]@ int[]::array(int&in, uint length) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $fact() */
void asea_jit165_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032714496 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # string[]@ string[]::array(int&in) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $fact(uint length, const int&in value) */
void asea_jit127_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032713216 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # int[]@ int[]::array(int&in, uint length, const int&in value) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $fact(uint length) */
void asea_jit166_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032714496 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # string[]@ string[]::array(int&in, uint length) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $fact() */
void asea_jit205_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032715776 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # Foo[]@ Foo[]::array(int&in) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $list(int&in list) { repeat int } */
void asea_jit128_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032713216 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $list # T[]@ $list(int&in type, int&in list) { repeat T } */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $fact(uint length, const string&in value) */
void asea_jit167_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032714496 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # string[]@ string[]::array(int&in, uint length, const string&in value) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $fact(uint length) */
void asea_jit206_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032715776 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # Foo[]@ Foo[]::array(int&in, uint length) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $list(int&in list) { repeat string } */
void asea_jit168_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032714496 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $list # T[]@ $list(int&in type, int&in list) { repeat T } */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $fact(uint length, const Foo&in value) */
void asea_jit207_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032715776 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # Foo[]@ Foo[]::array(int&in, uint length, const Foo&in value) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $list(int&in list) { repeat Foo } */
void asea_jit208_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761032715776 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $list # T[]@ $list(int&in type, int&in list) { repeat T } */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/arrays/initializationlists.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/initializationlists.as:2:5: Foo::Foo() */
void asea_jit117_module_scripts_2F_arrays_2F_initializationlists_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/initializationlists.as:2:5: Foo@ Foo() */
void asea_jit118_module_scripts_2F_arrays_2F_initializationlists_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761032712576 117 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/initializationlists.as:3:5: Foo::Foo(int value) */
void asea_jit119_module_scripts_2F_arrays_2F_initializationlists_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217744 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 -2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 3 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/initializationlists.as:3:5: Foo@ Foo(int value) */
void asea_jit120_module_scripts_2F_arrays_2F_initializationlists_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(0).as_asDWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761032712576 119 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/initializationlists.as:8:1: void main() */
void asea_jit116_module_scripts_2F_arrays_2F_initializationlists_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc32;
	case 3: goto bc39;
	case 4: goto bc51;
	case 5: goto bc61;
	case 6: goto bc68;
	case 7: goto bc78;
	case 8: goto bc84;
	case 9: goto bc91;
	case 10: goto bc103;
	case 11: goto bc122;
	case 12: goto bc129;
	case 13: goto bc140;
	case 14: goto bc153;
	case 15: goto bc162;
	case 16: goto bc169;
	case 17: goto bc175;
	case 18: goto bc183;
	case 19: goto bc194;
	case 20: goto bc207;
	case 21: goto bc214;
	case 22: goto bc220;
	case 23: goto bc226;
	case 24: goto bc233;
	case 25: goto bc239;
	case 26: goto bc247;
	case 27: goto bc258;
	case 28: goto bc271;
	case 29: goto bc284;
	case 30: goto bc291;
	case 31: goto bc297;
	case 32: goto bc305;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: AllocMem 4 16 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SetListSize 4 3 327757 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SetV4 5 123 */
	bc11: {
		ASEA_FRAME_VAR(5).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: PshListElmnt 4 4 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 5 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SetV4 5 456 */
	bc17: {
		ASEA_FRAME_VAR(5).as_asDWORD = (asDWORD)456;
		l_bc += 2;
	}
	/* bytecode: PshListElmnt 4 8 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 5 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SetV4 5 789 */
	bc23: {
		ASEA_FRAME_VAR(5).as_asDWORD = (asDWORD)789;
		l_bc += 2;
	}
	/* bytecode: PshListElmnt 4 12 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 5 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 4 */
	bc29: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALL $list # int[]@ $list(int&in list) { repeat int } */
	bc30: {
		extern char asea_script_fn128;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn128);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 4 751619308874 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: AllocMem 9 68 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SetListSize 9 2 590015 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshListElmnt 9 4 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string() */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc51: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236139720 */
	bc54: {
		extern void* asea_strobj0_asea_jit116_module_scripts_2F_arrays_2F_initializationlists_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_scripts_2F_arrays_2F_initializationlists_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshListElmnt 9 4 */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc59: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshListElmnt 9 36 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string() */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236140776 */
	bc71: {
		extern void* asea_strobj1_asea_jit116_module_scripts_2F_arrays_2F_initializationlists_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit116_module_scripts_2F_arrays_2F_initializationlists_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshListElmnt 9 36 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc78: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 9 */
	bc81: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(9).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALL $list # string[]@ $list(int&in list) { repeat string } */
	bc82: {
		extern char asea_script_fn168;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn168);
		return;
	}
	/* bytecode: JitEntry 8 */
	bc84: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 7 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 9 751619308874 */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc91: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: AllocMem 13 12 */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SetListSize 13 1 2 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshC4 123 */
	bc99: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: CALL Foo # Foo@ Foo(int value) */
	bc101: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 10 */
	bc103: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 15 */
	bc106: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 15 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 15 */
	bc108: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)15;
		l_bc++;
	}
	/* bytecode: PshListElmnt 13 4 */
	bc109: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJREF 2 */
	bc111: {
		asPWORD *dst = &ASEA_STACK_VAR(2).as_asPWORD;
		asPWORD var_idx = *dst;
		asPWORD var_addr = ASEA_FRAME_VAR(var_idx).as_asPWORD;
		ASEA_STACK_VAR(2).as_asPWORD = var_addr;
		l_bc++;
	}
	/* bytecode: REFCPY 137761032712576 */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpy calls yet */
	}
	/* bytecode: FREE 15 32074 */
	bc115: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc118: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: PshVPtr 13 */
	bc119: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(13).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALL $list # Foo[]@ $list(int&in list) { repeat Foo } */
	bc120: {
		extern char asea_script_fn208;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn208);
		return;
	}
	/* bytecode: JitEntry 11 */
	bc122: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 11 */
	bc125: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 13 751619308874 */
	bc126: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc129: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc132: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 16 0 */
	bc135: {
		ASEA_FRAME_VAR(16).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JMP 30 */
	bc137: {
		l_bc += 32;
		goto bc169;
	}
	/* bytecode: SUSPEND */
	bc139: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 13 */
	bc140: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc143: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc146: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 16 */
	bc149: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(16).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc150: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # int& int[]::opIndex(uint index) */
	bc151: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR4 5 */
	bc156: {
		asea_var* var = &ASEA_FRAME_VAR(5);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 18 5 */
	bc157: {
		ASEA_FRAME_VAR(18).as_asINT64 = ASEA_FRAME_VAR(5).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 18 */
	bc159: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(18).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc160: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc162: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc165: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 16 */
	bc168: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc169: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc172: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS length # uint int[]::length() const */
	bc173: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc175: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 5 */
	bc178: {
		ASEA_FRAME_VAR(5).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: CMPu 16 5 */
	bc179: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JS -44 */
	bc181: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += -42;
			goto bc139;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 18 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 16 0 */
	bc189: {
		ASEA_FRAME_VAR(16).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JMP 40 */
	bc191: {
		l_bc += 42;
		goto bc233;
	}
	/* bytecode: SUSPEND */
	bc193: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 19 */
	bc194: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc197: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc200: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 16 */
	bc203: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(16).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 7 */
	bc204: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(7).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # string& string[]::opIndex(uint index) */
	bc205: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc207: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshRPtr */
	bc210: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 26 */
	bc211: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc212: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc214: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 26 */
	bc217: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc218: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc220: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 26 */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc224: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 23 */
	bc226: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc229: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 16 */
	bc232: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 24 */
	bc233: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 7 */
	bc236: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(7).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS length # uint string[]::length() const */
	bc237: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 25 */
	bc239: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 5 */
	bc242: {
		ASEA_FRAME_VAR(5).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: CMPu 16 5 */
	bc243: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JS -54 */
	bc245: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += -52;
			goto bc193;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 26 */
	bc247: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc250: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 16 0 */
	bc253: {
		ASEA_FRAME_VAR(16).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JMP 34 */
	bc255: {
		l_bc += 36;
		goto bc291;
	}
	/* bytecode: SUSPEND */
	bc257: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 27 */
	bc258: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc261: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc264: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 16 */
	bc267: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(16).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 11 */
	bc268: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(11).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # Foo& Foo[]::opIndex(uint index) */
	bc269: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 28 */
	bc271: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshRPtr */
	bc274: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ADDSi 32 134217744 */
	bc275: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc277: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 5 */
	bc278: {
		asea_var* var = &ASEA_FRAME_VAR(5);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 18 5 */
	bc279: {
		ASEA_FRAME_VAR(18).as_asINT64 = ASEA_FRAME_VAR(5).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 18 */
	bc281: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(18).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc282: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 29 */
	bc284: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc287: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 16 */
	bc290: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 30 */
	bc291: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 11 */
	bc294: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(11).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS length # uint Foo[]::length() const */
	bc295: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 31 */
	bc297: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 5 */
	bc300: {
		ASEA_FRAME_VAR(5).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: CMPu 16 5 */
	bc301: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JS -48 */
	bc303: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += -46;
			goto bc257;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 32 */
	bc305: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 11 1970604009880906 */
	bc308: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 7 563229126327626 */
	bc311: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc314: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc317: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829502464 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4625196817309499392;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237004392 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829371392 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237127944 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829240320 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624070917402656768;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237247464 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829502464 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4625196817309499392;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237371112 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829371392 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237490632 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829240320 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624070917402656768;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237601992 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829502464 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4625196817309499392;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237721512 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829371392 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237841032 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829240320 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624070917402656768;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237964584 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829502464 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4625196817309499392;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238084104 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829371392 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238207752 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829240320 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624070917402656768;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238327272 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829502464 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4625196817309499392;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238438632 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829371392 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238558152 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298922528768 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624633867356078080;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198829240320 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4624070917402656768;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238681704 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPd 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4354352;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)1213516;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BAND64 4 2 6 */
	bc19: {
		asQWORD lhs = ASEA_FRAME_VAR(2).as_asQWORD;
		asQWORD rhs = ASEA_FRAME_VAR(6).as_asQWORD;
		ASEA_FRAME_VAR(4).as_asQWORD = lhs & rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4354352;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)1213516;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BOR64 4 2 6 */
	bc19: {
		asQWORD lhs = ASEA_FRAME_VAR(2).as_asQWORD;
		asQWORD rhs = ASEA_FRAME_VAR(6).as_asQWORD;
		ASEA_FRAME_VAR(4).as_asQWORD = lhs | rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4354352;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)1213516;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BXOR64 4 2 6 */
	bc19: {
		asQWORD lhs = ASEA_FRAME_VAR(2).as_asQWORD;
		asQWORD rhs = ASEA_FRAME_VAR(6).as_asQWORD;
		ASEA_FRAME_VAR(4).as_asQWORD = lhs ^ rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4354352;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)2;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 6 */
	bc19: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 7 4 */
	bc21: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: BSLL64 4 2 7 */
	bc23: {
		asQWORD lhs = ASEA_FRAME_VAR(2).as_asQWORD;
		asDWORD rhs = ASEA_FRAME_VAR(7).as_asDWORD;
		ASEA_FRAME_VAR(4).as_asQWORD = lhs << rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4354352;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)2;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 6 */
	bc19: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 7 4 */
	bc21: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: BSRL64 4 2 7 */
	bc23: {
		asQWORD lhs = ASEA_FRAME_VAR(2).as_asQWORD;
		asDWORD rhs = ASEA_FRAME_VAR(7).as_asDWORD;
		ASEA_FRAME_VAR(4).as_asQWORD = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563302140739583 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073705197264;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)2;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 6 */
	bc19: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 7 4 */
	bc21: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: BSRL64 4 2 7 */
	bc23: {
		asQWORD lhs = ASEA_FRAME_VAR(2).as_asQWORD;
		asDWORD rhs = ASEA_FRAME_VAR(7).as_asDWORD;
		ASEA_FRAME_VAR(4).as_asQWORD = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4354352;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)2;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 6 */
	bc19: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 7 4 */
	bc21: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: BSRA64 4 2 7 */
	bc23: {
		asINT64 lhs = ASEA_FRAME_VAR(2).as_asINT64;
		asDWORD rhs = ASEA_FRAME_VAR(7).as_asDWORD;
		ASEA_FRAME_VAR(4).as_asINT64 = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563302140739583 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073705197264;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)2;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 6 */
	bc19: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 7 4 */
	bc21: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: BSRA64 4 2 7 */
	bc23: {
		asINT64 lhs = ASEA_FRAME_VAR(2).as_asINT64;
		asDWORD rhs = ASEA_FRAME_VAR(7).as_asDWORD;
		ASEA_FRAME_VAR(4).as_asINT64 = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563301888094448 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)17361641481138401520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)8;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 6 */
	bc19: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 7 4 */
	bc21: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: BSRL64 4 2 7 */
	bc23: {
		asQWORD lhs = ASEA_FRAME_VAR(2).as_asQWORD;
		asDWORD rhs = ASEA_FRAME_VAR(7).as_asDWORD;
		ASEA_FRAME_VAR(4).as_asQWORD = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563301888094448 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)17361641481138401520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)8;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 6 */
	bc19: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOi 7 4 */
	bc21: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: BSRA64 4 2 7 */
	bc23: {
		asINT64 lhs = ASEA_FRAME_VAR(2).as_asINT64;
		asDWORD rhs = ASEA_FRAME_VAR(7).as_asDWORD;
		ASEA_FRAME_VAR(4).as_asINT64 = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563301888094448 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)17361641481138401520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: BNOT64 4 */
	bc16: {
		ASEA_FRAME_VAR(4).as_asQWORD = ~ ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PshV8 4 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/vec3f.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:0:0: Vec3f@ Vec3f(const Vec3f&inout other) */
void asea_jit142_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761040493056 141 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:0:0: Vec3f::Vec3f(const Vec3f&inout other) */
void asea_jit141_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:66:2: string Vec3f::FloatString() */
void asea_jit140_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc27;
	case 4: goto bc33;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc60;
	case 8: goto bc66;
	case 9: goto bc73;
	case 10: goto bc79;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 1 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 9 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730239809608 */
	bc11: {
		extern void* asea_strobj0_asea_jit140_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit140_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS opAdd_r # string string::opAdd_r(float) const */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc21: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 1 */
	bc22: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 17 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 9 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 9 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239809608 */
	bc36: {
		extern void* asea_strobj1_asea_jit140_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit140_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 9 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 17 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc54: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 1 */
	bc55: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 17 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 9 */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 9 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc66: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc69: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc70: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc77: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc79: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:61:2: string Vec3f::IntString() */
void asea_jit139_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc19;
	case 3: goto bc33;
	case 4: goto bc39;
	case 5: goto bc49;
	case 6: goto bc55;
	case 7: goto bc69;
	case 8: goto bc75;
	case 9: goto bc82;
	case 10: goto bc88;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: fTOi 1 */
	bc9: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_float;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc10: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc12: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 11 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730239809608 */
	bc14: {
		extern void* asea_strobj2_asea_jit139_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit139_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS opAdd_r # string string::opAdd_r(int64) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc24: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: fTOi 1 */
	bc25: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_float;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc26: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc28: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239809608 */
	bc42: {
		extern void* asea_strobj3_asea_jit139_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit139_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc60: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: fTOi 1 */
	bc61: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_float;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc62: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc64: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc69: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc75: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc78: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc79: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc88: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc91: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:56:2: void Vec3f::Print() */
void asea_jit138_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc23;
	case 4: goto bc29;
	case 5: goto bc39;
	case 6: goto bc45;
	case 7: goto bc56;
	case 8: goto bc62;
	case 9: goto bc72;
	case 10: goto bc78;
	case 11: goto bc89;
	case 12: goto bc95;
	case 13: goto bc101;
	case 14: goto bc107;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239808936 */
	bc6: {
		extern void* asea_strobj4_asea_jit138_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit138_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 9 */
	bc17: {
		asea_var* var = &ASEA_FRAME_VAR(9);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 9 */
	bc18: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 17 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239809128 */
	bc32: {
		extern void* asea_strobj5_asea_jit138_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit138_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 17 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc45: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 9 */
	bc50: {
		asea_var* var = &ASEA_FRAME_VAR(9);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 9 */
	bc51: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 17 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc59: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc62: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239809224 */
	bc65: {
		extern void* asea_strobj6_asea_jit138_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit138_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 17 */
	bc69: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc72: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc78: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 9 */
	bc83: {
		asea_var* var = &ASEA_FRAME_VAR(9);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 9 */
	bc84: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 17 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc89: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc95: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc98: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc101: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc104: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc105: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc107: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc110: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:51:2: Vec3f Vec3f::Lerp(const Vec3f&in desired, float t) */
void asea_jit137_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc62;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1065353216 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1065353216;
		l_bc += 2;
	}
	/* bytecode: SUBf 1 1 -4 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc18: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 -4 2 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ADDf 1 1 2 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: SetV4 2 1065353216 */
	bc24: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1065353216;
		l_bc += 2;
	}
	/* bytecode: SUBf 2 2 -4 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc30: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 3 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc36: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 3 -4 3 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ADDf 2 2 3 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc41: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: SetV4 3 1065353216 */
	bc42: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1065353216;
		l_bc += 2;
	}
	/* bytecode: SUBf 3 3 -4 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 4 */
	bc48: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 3 3 4 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 4 */
	bc54: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 4 -4 4 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ADDf 3 3 4 */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc59: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc60: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc62: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 6 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 6 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 6 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 5 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:49:2: void Vec3f::opAssign(const Vec3f&in oof) */
void asea_jit136_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	case 4: goto bc33;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:47:2: void Vec3f::opDivAssign(float oof) */
void asea_jit135_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 1 1 -2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc17: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 1 1 -2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc26: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 1 1 -2 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 3 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:45:2: Vec3f Vec3f::opDiv(float oof) */
void asea_jit134_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc26;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 1 1 -2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc11: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc14: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 2 2 -2 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc20: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 3 3 -2 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc24: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 5 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 5 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 5 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:43:2: Vec3f Vec3f::opDiv(const Vec3f&in oof) const */
void asea_jit133_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc38;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc18: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 2 2 3 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc28: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 4 */
	bc32: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: DIVf 3 3 4 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc36: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 6 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 6 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 4 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:41:2: void Vec3f::opMulAssign(float oof) */
void asea_jit132_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 -2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc17: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 -2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc26: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 -2 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 3 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:39:2: Vec3f Vec3f::opMul(float oof) const */
void asea_jit131_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc26;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 -2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc11: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc14: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 -2 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc20: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 3 3 -2 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc24: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 5 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 5 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 5 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:37:2: Vec3f Vec3f::opMul(const Vec3f&in oof) */
void asea_jit130_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc38;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc18: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 3 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc28: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 4 */
	bc32: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 3 3 4 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc36: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 6 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 6 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 4 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:35:2: void Vec3f::opSubAssign(const Vec3f&in oof) */
void asea_jit129_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc29;
	case 4: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc25: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 2 2 1 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 2 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc35: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc38: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 1 1 2 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:72:1: float DotProduct(const Vec3f&in v1, const Vec3f&in v2) */
void asea_jit116_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc17: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc21: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ADDf 3 1 2 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc28: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc32: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 1 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ADDf 1 3 2 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CpyVtoR4 1 */
	bc37: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: RET 4 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:77:1: Vec3f CrossProduct(const Vec3f&in v1, const Vec3f&in v2) */
void asea_jit117_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc71;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc17: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc21: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SUBf 3 1 2 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc33: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 1 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc38: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 4 */
	bc42: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 4 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SUBf 4 2 1 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 4 */
	bc47: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(4).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc50: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc54: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 1 1 2 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc59: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 5 */
	bc63: {
		asea_var* var = &ASEA_FRAME_VAR(5);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: MULf 2 2 5 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: SUBf 5 1 2 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 5 */
	bc68: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(5).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc69: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 7 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 7 */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 7 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 4 */
	bc77: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:82:1: void main() */
void asea_jit118_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc18;
	case 4: goto bc29;
	case 5: goto bc33;
	case 6: goto bc42;
	case 7: goto bc49;
	case 8: goto bc58;
	case 9: goto bc64;
	case 10: goto bc70;
	case 11: goto bc76;
	case 12: goto bc86;
	case 13: goto bc93;
	case 14: goto bc99;
	case 15: goto bc108;
	case 16: goto bc115;
	case 17: goto bc121;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 1092616192 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 1092616192;
		l_bc += 2;
	}
	/* bytecode: PshC4 1092616192 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 1092616192;
		l_bc += 2;
	}
	/* bytecode: PshC4 1092616192 */
	bc10: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 1092616192;
		l_bc += 2;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc12: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 0;
		l_bc += 2;
	}
	/* bytecode: PshC4 1084227584 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 1084227584;
		l_bc += 2;
	}
	/* bytecode: PshC4 1092616192 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 1092616192;
		l_bc += 2;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc27: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 7 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239798376 */
	bc36: {
		extern void* asea_strobj7_asea_jit118_module_scripts_2F_vec3f_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj7_asea_jit118_module_scripts_2F_vec3f_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 7 */
	bc45: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(7).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc46: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALL DotProduct # float DotProduct(const Vec3f&in v1, const Vec3f&in v2) */
	bc47: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 3 */
	bc52: {
		ASEA_FRAME_VAR(3).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 3 */
	bc53: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc64: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc70: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc76: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc79: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 7 */
	bc82: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(7).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc83: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALL CrossProduct # Vec3f CrossProduct(const Vec3f&in v1, const Vec3f&in v2) */
	bc84: {
		extern char asea_script_fn117;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn117);
		return;
	}
	/* bytecode: JitEntry 12 */
	bc86: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 25 */
	bc89: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 25 */
	bc90: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(25).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 158 */
	bc91: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 25 751619308874 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc99: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 1056964608 */
	bc102: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 1056964608;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 7 */
	bc104: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(7).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc105: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 157 */
	bc106: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc108: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 25 */
	bc111: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 25 */
	bc112: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(25).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 158 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 25 751619308874 */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc121: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 7 563229126327626 */
	bc124: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc127: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc130: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:9:2: Vec3f::Vec3f() */
void asea_jit119_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 0 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 0 */
	bc14: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 0 */
	bc22: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:9:2: Vec3f@ Vec3f() */
void asea_jit120_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761040493056 119 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:16:2: Vec3f::Vec3f(float _x, float _y, float _z) */
void asea_jit121_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	case 3: goto bc15;
	case 4: goto bc21;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 -2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 -3 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 -4 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 5 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:16:2: Vec3f@ Vec3f(float _x, float _y, float _z) */
void asea_jit122_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 -2 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshV4 -1 */
	bc5: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(-1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshV4 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(0).as_asDWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761040493056 121 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:23:2: Vec3f Vec3f::opAdd(const Vec3f&in oof) const */
void asea_jit123_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc38;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc18: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 2 2 3 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc28: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 4 */
	bc32: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 3 3 4 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc36: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 6 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 6 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 4 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:25:2: Vec3f Vec3f::opAdd(float oof) const */
void asea_jit124_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc26;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 1 1 -2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc11: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc14: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 2 2 -2 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc20: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 3 3 -2 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc24: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 5 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 5 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 5 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:27:2: void Vec3f::opAddAssign(const Vec3f&in oof) */
void asea_jit125_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc29;
	case 4: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc25: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 2 2 1 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 2 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc35: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc38: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 1 1 2 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:29:2: void Vec3f::opAddAssign(float oof) */
void asea_jit126_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 1 1 -2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc17: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 1 1 -2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc26: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: ADDf 1 1 -2 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 3 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:31:2: Vec3f Vec3f::opSub(const Vec3f&in oof) const */
void asea_jit127_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc38;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc12: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc18: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 2 2 3 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc28: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 4 */
	bc32: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 3 3 4 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc36: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 6 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 6 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 4 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/vec3f.as:33:2: Vec3f Vec3f::opSub(float oof) const */
void asea_jit128_module_scripts_2F_vec3f_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc26;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 1 1 -2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 1 */
	bc11: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc14: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 2 2 -2 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc20: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: SUBf 3 3 -2 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL Vec3f # Vec3f@ Vec3f(float _x, float _y, float _z) */
	bc24: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 5 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 5 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: LOADOBJ 5 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298920112324 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4614255322014802772;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242237544 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: dTOf 5 4 */
	bc25: {
		ASEA_FRAME_VAR(5).as_float = ASEA_FRAME_VAR(4).as_double;
		l_bc += 2;
	}
	/* bytecode: PshV4 5 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(5).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 21 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 13 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 21 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 21 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1078527525 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1078527525;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242337672 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: fTOd 4 2 */
	bc22: {
		ASEA_FRAME_VAR(4).as_double = ASEA_FRAME_VAR(2).as_float;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/stringmanip.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:43:1: void string_function_value() */
void asea_jit123_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc21;
	case 4: goto bc27;
	case 5: goto bc38;
	case 6: goto bc46;
	case 7: goto bc52;
	case 8: goto bc63;
	case 9: goto bc71;
	case 10: goto bc77;
	case 11: goto bc86;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730242468904 */
	bc7: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761041615616 20 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 10 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)10;
		l_bc++;
	}
	/* bytecode: PSF 12 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730242469000 */
	bc32: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761041615616 20 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 12 */
	bc55: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)12;
		l_bc++;
	}
	/* bytecode: PSF 14 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730242445960 */
	bc57: {
		extern void* asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761041615616 20 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 14 */
	bc80: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)14;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 2 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 4 */
	bc83: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL takes_string_value # void takes_string_value(string a, string b, string c) */
	bc84: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 11 */
	bc86: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc89: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:38:1: void takes_string_value(string a, string b, string c) */
void asea_jit122_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 18446181402929036618 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -2 18445618452975615306 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -4 1688892809968970 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 6 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:33:1: void string_function_reference() */
void asea_jit121_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc17;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242468904 */
	bc6: {
		extern void* asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242469000 */
	bc9: {
		extern void* asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242445960 */
	bc12: {
		extern void* asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL takes_string_reference # void takes_string_reference(const string&in a, const string&in b, const string&in c) */
	bc15: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:28:1: void takes_string_reference(const string&in a, const string&in b, const string&in c) */
void asea_jit120_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:22:1: void string_manylocals_concat() */
void asea_jit119_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc39;
	case 6: goto bc48;
	case 7: goto bc57;
	case 8: goto bc68;
	case 9: goto bc76;
	case 10: goto bc82;
	case 11: goto bc90;
	case 12: goto bc96;
	case 13: goto bc104;
	case 14: goto bc110;
	case 15: goto bc118;
	case 16: goto bc124;
	case 17: goto bc134;
	case 18: goto bc140;
	case 19: goto bc146;
	case 20: goto bc152;
	case 21: goto bc161;
	case 22: goto bc167;
	case 23: goto bc173;
	case 24: goto bc179;
	case 25: goto bc185;
	case 26: goto bc191;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242457768 */
	bc6: {
		extern void* asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242457960 */
	bc15: {
		extern void* asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242458248 */
	bc24: {
		extern void* asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242458248 */
	bc33: {
		extern void* asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242458728 */
	bc42: {
		extern void* asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242459016 */
	bc51: {
		extern void* asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc57: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc76: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc90: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc101: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc104: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc108: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc110: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc114: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc115: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc116: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc118: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc121: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc122: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc124: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242449704 */
	bc127: {
		extern void* asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc130: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc131: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc132: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc137: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc138: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc140: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc143: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc144: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc146: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc149: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc150: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc152: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc155: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc158: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc161: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc164: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc165: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc167: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc170: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc171: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 23 */
	bc173: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc176: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc177: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 24 */
	bc179: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc182: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc183: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 25 */
	bc185: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc188: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 26 */
	bc191: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc194: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:15:1: void string_concat2() */
void asea_jit118_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc24;
	case 4: goto bc33;
	case 5: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242449512 */
	bc6: {
		extern void* asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242449704 */
	bc18: {
		extern void* asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAddAssign # string& string::opAddAssign(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:9:1: void string_concat() */
void asea_jit117_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc53;
	case 8: goto bc59;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242449512 */
	bc6: {
		extern void* asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242449704 */
	bc15: {
		extern void* asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 24 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:3:1: void string_ref() */
void asea_jit116_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242445960 */
	bc6: {
		extern void* asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/stringmanip.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:43:1: void string_function_value() */
void asea_jit123_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc21;
	case 4: goto bc27;
	case 5: goto bc38;
	case 6: goto bc46;
	case 7: goto bc52;
	case 8: goto bc63;
	case 9: goto bc71;
	case 10: goto bc77;
	case 11: goto bc86;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730243243240 */
	bc7: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761041947776 20 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 10 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)10;
		l_bc++;
	}
	/* bytecode: PSF 12 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730243243336 */
	bc32: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761041947776 20 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 12 */
	bc55: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)12;
		l_bc++;
	}
	/* bytecode: PSF 14 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730243220296 */
	bc57: {
		extern void* asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761041947776 20 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 14 */
	bc80: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)14;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 2 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 4 */
	bc83: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL takes_string_value # void takes_string_value(string a, string b, string c) */
	bc84: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 11 */
	bc86: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc89: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:38:1: void takes_string_value(string a, string b, string c) */
void asea_jit122_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 18446181402929036618 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -2 18445618452975615306 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -4 1688892809968970 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 6 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:33:1: void string_function_reference() */
void asea_jit121_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc17;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243243240 */
	bc6: {
		extern void* asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243243336 */
	bc9: {
		extern void* asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243220296 */
	bc12: {
		extern void* asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL takes_string_reference # void takes_string_reference(const string&in a, const string&in b, const string&in c) */
	bc15: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:28:1: void takes_string_reference(const string&in a, const string&in b, const string&in c) */
void asea_jit120_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:22:1: void string_manylocals_concat() */
void asea_jit119_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc39;
	case 6: goto bc48;
	case 7: goto bc57;
	case 8: goto bc68;
	case 9: goto bc76;
	case 10: goto bc82;
	case 11: goto bc90;
	case 12: goto bc96;
	case 13: goto bc104;
	case 14: goto bc110;
	case 15: goto bc118;
	case 16: goto bc124;
	case 17: goto bc134;
	case 18: goto bc140;
	case 19: goto bc146;
	case 20: goto bc152;
	case 21: goto bc161;
	case 22: goto bc167;
	case 23: goto bc173;
	case 24: goto bc179;
	case 25: goto bc185;
	case 26: goto bc191;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243232104 */
	bc6: {
		extern void* asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243232296 */
	bc15: {
		extern void* asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243232584 */
	bc24: {
		extern void* asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243232584 */
	bc33: {
		extern void* asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243233064 */
	bc42: {
		extern void* asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243233352 */
	bc51: {
		extern void* asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc57: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc76: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc90: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc101: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc104: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc108: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc110: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc114: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc115: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc116: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc118: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc121: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc122: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc124: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243224040 */
	bc127: {
		extern void* asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc130: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc131: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc132: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc137: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc138: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc140: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc143: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc144: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc146: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc149: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc150: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc152: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc155: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc158: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc161: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc164: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc165: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc167: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc170: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc171: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 23 */
	bc173: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc176: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc177: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 24 */
	bc179: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc182: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc183: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 25 */
	bc185: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc188: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 26 */
	bc191: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc194: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:15:1: void string_concat2() */
void asea_jit118_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc24;
	case 4: goto bc33;
	case 5: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243223848 */
	bc6: {
		extern void* asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243224040 */
	bc18: {
		extern void* asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAddAssign # string& string::opAddAssign(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:9:1: void string_concat() */
void asea_jit117_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc53;
	case 8: goto bc59;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243223848 */
	bc6: {
		extern void* asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243224040 */
	bc15: {
		extern void* asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 24 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:3:1: void string_ref() */
void asea_jit116_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243220296 */
	bc6: {
		extern void* asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/stringmanip.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:43:1: void string_function_value() */
void asea_jit123_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc21;
	case 4: goto bc27;
	case 5: goto bc38;
	case 6: goto bc46;
	case 7: goto bc52;
	case 8: goto bc63;
	case 9: goto bc71;
	case 10: goto bc77;
	case 11: goto bc86;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730244017576 */
	bc7: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042279296 20 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 10 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)10;
		l_bc++;
	}
	/* bytecode: PSF 12 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730244017672 */
	bc32: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042279296 20 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 12 */
	bc55: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)12;
		l_bc++;
	}
	/* bytecode: PSF 14 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730243994632 */
	bc57: {
		extern void* asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042279296 20 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 14 */
	bc80: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)14;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 2 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 4 */
	bc83: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL takes_string_value # void takes_string_value(string a, string b, string c) */
	bc84: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 11 */
	bc86: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc89: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:38:1: void takes_string_value(string a, string b, string c) */
void asea_jit122_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 18446181402929036618 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -2 18445618452975615306 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -4 1688892809968970 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 6 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:33:1: void string_function_reference() */
void asea_jit121_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc17;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244017576 */
	bc6: {
		extern void* asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244017672 */
	bc9: {
		extern void* asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243994632 */
	bc12: {
		extern void* asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL takes_string_reference # void takes_string_reference(const string&in a, const string&in b, const string&in c) */
	bc15: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:28:1: void takes_string_reference(const string&in a, const string&in b, const string&in c) */
void asea_jit120_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:22:1: void string_manylocals_concat() */
void asea_jit119_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc39;
	case 6: goto bc48;
	case 7: goto bc57;
	case 8: goto bc68;
	case 9: goto bc76;
	case 10: goto bc82;
	case 11: goto bc90;
	case 12: goto bc96;
	case 13: goto bc104;
	case 14: goto bc110;
	case 15: goto bc118;
	case 16: goto bc124;
	case 17: goto bc134;
	case 18: goto bc140;
	case 19: goto bc146;
	case 20: goto bc152;
	case 21: goto bc161;
	case 22: goto bc167;
	case 23: goto bc173;
	case 24: goto bc179;
	case 25: goto bc185;
	case 26: goto bc191;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244006440 */
	bc6: {
		extern void* asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244006632 */
	bc15: {
		extern void* asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244006920 */
	bc24: {
		extern void* asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244006920 */
	bc33: {
		extern void* asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244007400 */
	bc42: {
		extern void* asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244007688 */
	bc51: {
		extern void* asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc57: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc76: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc90: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc101: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc104: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc108: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc110: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc114: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc115: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc116: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc118: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc121: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc122: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc124: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243998376 */
	bc127: {
		extern void* asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc130: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc131: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc132: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc137: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc138: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc140: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc143: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc144: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc146: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc149: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc150: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc152: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc155: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc158: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc161: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc164: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc165: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc167: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc170: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc171: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 23 */
	bc173: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc176: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc177: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 24 */
	bc179: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc182: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc183: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 25 */
	bc185: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc188: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 26 */
	bc191: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc194: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:15:1: void string_concat2() */
void asea_jit118_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc24;
	case 4: goto bc33;
	case 5: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243998184 */
	bc6: {
		extern void* asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243998376 */
	bc18: {
		extern void* asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAddAssign # string& string::opAddAssign(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:9:1: void string_concat() */
void asea_jit117_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc53;
	case 8: goto bc59;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243998184 */
	bc6: {
		extern void* asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243998376 */
	bc15: {
		extern void* asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 24 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:3:1: void string_ref() */
void asea_jit116_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243994632 */
	bc6: {
		extern void* asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/stringmanip.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:43:1: void string_function_value() */
void asea_jit123_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc21;
	case 4: goto bc27;
	case 5: goto bc38;
	case 6: goto bc46;
	case 7: goto bc52;
	case 8: goto bc63;
	case 9: goto bc71;
	case 10: goto bc77;
	case 11: goto bc86;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730244791912 */
	bc7: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042612096 20 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 10 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)10;
		l_bc++;
	}
	/* bytecode: PSF 12 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730244792008 */
	bc32: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042612096 20 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 12 */
	bc55: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)12;
		l_bc++;
	}
	/* bytecode: PSF 14 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730244768968 */
	bc57: {
		extern void* asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042612096 20 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 14 */
	bc80: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)14;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 2 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 4 */
	bc83: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL takes_string_value # void takes_string_value(string a, string b, string c) */
	bc84: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 11 */
	bc86: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc89: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:38:1: void takes_string_value(string a, string b, string c) */
void asea_jit122_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 18446181402929036618 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -2 18445618452975615306 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -4 1688892809968970 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 6 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:33:1: void string_function_reference() */
void asea_jit121_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc17;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244791912 */
	bc6: {
		extern void* asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244792008 */
	bc9: {
		extern void* asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244768968 */
	bc12: {
		extern void* asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL takes_string_reference # void takes_string_reference(const string&in a, const string&in b, const string&in c) */
	bc15: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:28:1: void takes_string_reference(const string&in a, const string&in b, const string&in c) */
void asea_jit120_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:22:1: void string_manylocals_concat() */
void asea_jit119_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc39;
	case 6: goto bc48;
	case 7: goto bc57;
	case 8: goto bc68;
	case 9: goto bc76;
	case 10: goto bc82;
	case 11: goto bc90;
	case 12: goto bc96;
	case 13: goto bc104;
	case 14: goto bc110;
	case 15: goto bc118;
	case 16: goto bc124;
	case 17: goto bc134;
	case 18: goto bc140;
	case 19: goto bc146;
	case 20: goto bc152;
	case 21: goto bc161;
	case 22: goto bc167;
	case 23: goto bc173;
	case 24: goto bc179;
	case 25: goto bc185;
	case 26: goto bc191;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244780776 */
	bc6: {
		extern void* asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244780968 */
	bc15: {
		extern void* asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244781256 */
	bc24: {
		extern void* asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244781256 */
	bc33: {
		extern void* asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244781736 */
	bc42: {
		extern void* asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244782024 */
	bc51: {
		extern void* asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc57: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc76: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc90: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc101: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc104: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc108: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc110: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc114: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc115: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc116: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc118: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc121: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc122: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc124: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244772712 */
	bc127: {
		extern void* asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc130: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc131: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc132: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc137: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc138: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc140: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc143: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc144: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc146: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc149: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc150: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc152: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc155: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc158: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc161: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc164: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc165: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc167: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc170: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc171: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 23 */
	bc173: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc176: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc177: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 24 */
	bc179: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc182: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc183: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 25 */
	bc185: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc188: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 26 */
	bc191: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc194: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:15:1: void string_concat2() */
void asea_jit118_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc24;
	case 4: goto bc33;
	case 5: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244772520 */
	bc6: {
		extern void* asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244772712 */
	bc18: {
		extern void* asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAddAssign # string& string::opAddAssign(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:9:1: void string_concat() */
void asea_jit117_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc53;
	case 8: goto bc59;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244772520 */
	bc6: {
		extern void* asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244772712 */
	bc15: {
		extern void* asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 24 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:3:1: void string_ref() */
void asea_jit116_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244768968 */
	bc6: {
		extern void* asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/stringmanip.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:43:1: void string_function_value() */
void asea_jit123_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc21;
	case 4: goto bc27;
	case 5: goto bc38;
	case 6: goto bc46;
	case 7: goto bc52;
	case 8: goto bc63;
	case 9: goto bc71;
	case 10: goto bc77;
	case 11: goto bc86;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730232412040 */
	bc7: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761025750016 20 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 10 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)10;
		l_bc++;
	}
	/* bytecode: PSF 12 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730232412136 */
	bc32: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761025750016 20 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 12 */
	bc55: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)12;
		l_bc++;
	}
	/* bytecode: PSF 14 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730245537640 */
	bc57: {
		extern void* asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761025750016 20 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 14 */
	bc80: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)14;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 2 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 4 */
	bc83: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL takes_string_value # void takes_string_value(string a, string b, string c) */
	bc84: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 11 */
	bc86: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc89: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:38:1: void takes_string_value(string a, string b, string c) */
void asea_jit122_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 18446181402929036618 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -2 18445618452975615306 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -4 1688892809968970 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 6 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:33:1: void string_function_reference() */
void asea_jit121_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc17;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232412040 */
	bc6: {
		extern void* asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232412136 */
	bc9: {
		extern void* asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245537640 */
	bc12: {
		extern void* asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL takes_string_reference # void takes_string_reference(const string&in a, const string&in b, const string&in c) */
	bc15: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:28:1: void takes_string_reference(const string&in a, const string&in b, const string&in c) */
void asea_jit120_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:22:1: void string_manylocals_concat() */
void asea_jit119_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc39;
	case 6: goto bc48;
	case 7: goto bc57;
	case 8: goto bc68;
	case 9: goto bc76;
	case 10: goto bc82;
	case 11: goto bc90;
	case 12: goto bc96;
	case 13: goto bc104;
	case 14: goto bc110;
	case 15: goto bc118;
	case 16: goto bc124;
	case 17: goto bc134;
	case 18: goto bc140;
	case 19: goto bc146;
	case 20: goto bc152;
	case 21: goto bc161;
	case 22: goto bc167;
	case 23: goto bc173;
	case 24: goto bc179;
	case 25: goto bc185;
	case 26: goto bc191;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232401288 */
	bc6: {
		extern void* asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232396296 */
	bc15: {
		extern void* asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232505064 */
	bc24: {
		extern void* asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232505064 */
	bc33: {
		extern void* asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232508520 */
	bc42: {
		extern void* asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232507944 */
	bc51: {
		extern void* asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc57: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc76: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc90: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc101: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc104: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc108: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc110: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc114: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc115: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc116: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc118: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc121: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc122: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc124: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232518216 */
	bc127: {
		extern void* asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc130: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc131: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc132: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc137: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc138: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc140: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc143: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc144: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc146: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc149: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc150: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc152: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc155: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc158: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc161: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc164: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc165: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc167: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc170: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc171: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 23 */
	bc173: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc176: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc177: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 24 */
	bc179: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc182: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc183: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 25 */
	bc185: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc188: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 26 */
	bc191: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc194: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:15:1: void string_concat2() */
void asea_jit118_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc24;
	case 4: goto bc33;
	case 5: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232518984 */
	bc6: {
		extern void* asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232518216 */
	bc18: {
		extern void* asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAddAssign # string& string::opAddAssign(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:9:1: void string_concat() */
void asea_jit117_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc53;
	case 8: goto bc59;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232518984 */
	bc6: {
		extern void* asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232518216 */
	bc15: {
		extern void* asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 24 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:3:1: void string_ref() */
void asea_jit116_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245537640 */
	bc6: {
		extern void* asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/stringmanip.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:43:1: void string_function_value() */
void asea_jit123_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc21;
	case 4: goto bc27;
	case 5: goto bc38;
	case 6: goto bc46;
	case 7: goto bc52;
	case 8: goto bc63;
	case 9: goto bc71;
	case 10: goto bc77;
	case 11: goto bc86;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730231750984 */
	bc7: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761025442816 20 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 10 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)10;
		l_bc++;
	}
	/* bytecode: PSF 12 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730231751080 */
	bc32: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761025442816 20 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 12 */
	bc55: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)12;
		l_bc++;
	}
	/* bytecode: PSF 14 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PGA 136730231728040 */
	bc57: {
		extern void* asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit123_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761025442816 20 */
	bc67: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 14 */
	bc80: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)14;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 2 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETOBJ 4 */
	bc83: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL takes_string_value # void takes_string_value(string a, string b, string c) */
	bc84: {
		extern char asea_script_fn122;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn122);
		return;
	}
	/* bytecode: JitEntry 11 */
	bc86: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc89: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:38:1: void takes_string_value(string a, string b, string c) */
void asea_jit122_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 18446181402929036618 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -2 18445618452975615306 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE -4 1688892809968970 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 6 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:33:1: void string_function_reference() */
void asea_jit121_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc17;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231750984 */
	bc6: {
		extern void* asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231751080 */
	bc9: {
		extern void* asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231728040 */
	bc12: {
		extern void* asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit121_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL takes_string_reference # void takes_string_reference(const string&in a, const string&in b, const string&in c) */
	bc15: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:28:1: void takes_string_reference(const string&in a, const string&in b, const string&in c) */
void asea_jit120_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 8 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -4 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PSF 16 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 6 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:22:1: void string_manylocals_concat() */
void asea_jit119_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc39;
	case 6: goto bc48;
	case 7: goto bc57;
	case 8: goto bc68;
	case 9: goto bc76;
	case 10: goto bc82;
	case 11: goto bc90;
	case 12: goto bc96;
	case 13: goto bc104;
	case 14: goto bc110;
	case 15: goto bc118;
	case 16: goto bc124;
	case 17: goto bc134;
	case 18: goto bc140;
	case 19: goto bc146;
	case 20: goto bc152;
	case 21: goto bc161;
	case 22: goto bc167;
	case 23: goto bc173;
	case 24: goto bc179;
	case 25: goto bc185;
	case 26: goto bc191;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231739848 */
	bc6: {
		extern void* asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231740040 */
	bc15: {
		extern void* asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj7_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231740328 */
	bc24: {
		extern void* asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj8_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231740328 */
	bc33: {
		extern void* asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj9_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231740808 */
	bc42: {
		extern void* asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj10_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231741096 */
	bc51: {
		extern void* asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj11_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc57: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc65: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc76: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc87: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc90: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc101: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc104: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc108: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc110: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc114: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 64 */
	bc115: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc116: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc118: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc121: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc122: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc124: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231731784 */
	bc127: {
		extern void* asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj12_asea_jit119_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc130: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 56 */
	bc131: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc132: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 56 */
	bc137: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc138: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc140: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc143: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc144: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc146: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 64 */
	bc149: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc150: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc152: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc155: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 48 */
	bc158: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc161: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 40 */
	bc164: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc165: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc167: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 32 */
	bc170: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc171: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 23 */
	bc173: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc176: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc177: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 24 */
	bc179: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc182: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc183: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 25 */
	bc185: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc188: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 26 */
	bc191: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc194: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:15:1: void string_concat2() */
void asea_jit118_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc24;
	case 4: goto bc33;
	case 5: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231731592 */
	bc6: {
		extern void* asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj13_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231731784 */
	bc18: {
		extern void* asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj14_asea_jit118_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAddAssign # string& string::opAddAssign(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:9:1: void string_concat() */
void asea_jit117_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc53;
	case 8: goto bc59;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231731592 */
	bc6: {
		extern void* asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj15_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231731784 */
	bc15: {
		extern void* asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj16_asea_jit117_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 24 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(const string&in) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 24 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc57: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/stringmanip.as:3:1: void string_ref() */
void asea_jit116_module_scripts_2F_stringmanip_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	case 4: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231728040 */
	bc6: {
		extern void* asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj17_asea_jit116_module_scripts_2F_stringmanip_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc22;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 1 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)1;
		l_bc++;
	}
	/* bytecode: PshC4 16 */
	bc7: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 16;
		l_bc += 2;
	}
	/* bytecode: PGA 136730245877960 */
	bc9: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: GETREF 3 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS parseInt # int64 parseInt(const string&in, uint base = 10, uint&out byteCount = 0) */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV8 4 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	case 7: goto bc43;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1078527525 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1078527525;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245946888 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 1 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1065353216 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1065353216;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1073741824 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1073741824;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730246041160 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDf 2 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1065353216 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1065353216;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1073741824 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1073741824;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730246138024 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SUBf 2 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1084227584 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1084227584;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1073741824 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1073741824;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730246234888 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MULf 2 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1084227584 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1084227584;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1073741824 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1073741824;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232627176 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DIVf 2 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1092616192 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1092616192;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1086324736 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1086324736;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233489160 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MODf 2 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc28;
	case 5: goto bc34;
	case 6: goto bc40;
	case 7: goto bc46;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1092616192 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1092616192;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233383848 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: NEGf 2 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc14;
	case 4: goto bc23;
	case 5: goto bc31;
	case 6: goto bc37;
	case 7: goto bc43;
	case 8: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1065353216 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1065353216;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDIf 1 1 1073741824 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233243496 */
	bc17: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 1 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc14;
	case 4: goto bc23;
	case 5: goto bc31;
	case 6: goto bc37;
	case 7: goto bc43;
	case 8: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1065353216 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1065353216;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SUBIf 1 1 1073741824 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233337384 */
	bc17: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 1 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc14;
	case 4: goto bc23;
	case 5: goto bc31;
	case 6: goto bc37;
	case 7: goto bc43;
	case 8: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1084227584 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1084227584;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MULIf 1 1 1073741824 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233192040 */
	bc17: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 1 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc15;
	case 4: goto bc24;
	case 5: goto bc32;
	case 6: goto bc38;
	case 7: goto bc44;
	case 8: goto bc50;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1084227584 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1084227584;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 2 1073741824 */
	bc11: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1073741824;
		l_bc += 2;
	}
	/* bytecode: DIVf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233042760 */
	bc18: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 1 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc15;
	case 4: goto bc24;
	case 5: goto bc32;
	case 6: goto bc38;
	case 7: goto bc44;
	case 8: goto bc50;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1092616192 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1092616192;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 2 1086324736 */
	bc11: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1086324736;
		l_bc += 2;
	}
	/* bytecode: MODf 1 1 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232901736 */
	bc18: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 1 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc28;
	case 5: goto bc34;
	case 6: goto bc40;
	case 7: goto bc46;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1092616192 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1092616192;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232868424 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc20: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: INCf */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc28;
	case 5: goto bc34;
	case 6: goto bc40;
	case 7: goto bc46;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1092616192 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1092616192;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232766376 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc20: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: DECf */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc22: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4354352;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1213516 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1213516;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BAND 2 1 3 */
	bc13: {
		asDWORD lhs = ASEA_FRAME_VAR(1).as_asDWORD;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asDWORD = lhs & rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4354352;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1213516 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1213516;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BOR 2 1 3 */
	bc13: {
		asDWORD lhs = ASEA_FRAME_VAR(1).as_asDWORD;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asDWORD = lhs | rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4354352;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 1213516 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1213516;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BXOR 2 1 3 */
	bc13: {
		asDWORD lhs = ASEA_FRAME_VAR(1).as_asDWORD;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asDWORD = lhs ^ rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4354352;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)2;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BSLL 2 1 3 */
	bc13: {
		asDWORD lhs = ASEA_FRAME_VAR(1).as_asDWORD;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asDWORD = lhs << rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4354352;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)2;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BSRL 2 1 3 */
	bc13: {
		asDWORD lhs = ASEA_FRAME_VAR(1).as_asDWORD;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asDWORD = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 -4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4290612944;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)2;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BSRL 2 1 3 */
	bc13: {
		asDWORD lhs = ASEA_FRAME_VAR(1).as_asDWORD;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asDWORD = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4354352;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)2;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BSRA 2 1 3 */
	bc13: {
		asINT32 lhs = ASEA_FRAME_VAR(1).as_asINT32;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 -4354352 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4290612944;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)2;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: BSRA 2 1 3 */
	bc13: {
		asINT32 lhs = ASEA_FRAME_VAR(1).as_asINT32;
		asDWORD rhs = ASEA_FRAME_VAR(3).as_asDWORD;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs >> rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc19;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 -252645136 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4042322160;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc11: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: BNOT 2 */
	bc13: {
		ASEA_FRAME_VAR(2).as_asDWORD = ~ ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: uTOi64 4 2 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: asbc_pga_test */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/bc_pga_var_test.as:3:1: void foo() */
void asea_jit117_module_asbc_5F_pga_5F_test(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc25;
	case 3: goto bc37;
	case 4: goto bc45;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshGPtr 137073828728344 */
	bc6: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RefCpyV 2 32074 */
	bc9: {
		asPWORD *dst = &ASEA_FRAME_VAR(2).as_asPWORD;
		asPWORD src = ASEA_STACK_TOP.as_asPWORD;
		*dst = src;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PopPtr */
	bc12: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: VAR 2 */
	bc13: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)2;
		l_bc++;
	}
	/* bytecode: PGA 137073828725200 */
	bc14: {
		extern void* asea_global1;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_global1;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: GETOBJREF 2 */
	bc17: {
		asPWORD *dst = &ASEA_STACK_VAR(2).as_asPWORD;
		asPWORD var_idx = *dst;
		asPWORD var_addr = ASEA_FRAME_VAR(var_idx).as_asPWORD;
		ASEA_STACK_VAR(2).as_asPWORD = var_addr;
		l_bc++;
	}
	/* bytecode: REFCPY 137761028418176 */
	bc18: {
		asPWORD *dst = (asPWORD*)ASEA_STACK_TOP.as_asPWORD;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		asPWORD src = ASEA_STACK_TOP.as_asPWORD;
		*dst = src;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 32074 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: JitEntry 2 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 3 123 */
	bc28: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: PshGPtr 137073828725200 */
	bc30: {
		extern void* asea_global1;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global1;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDSi 8 67108878 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 3 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshGPtr 137073828728344 */
	bc40: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS foo # void Base::foo() */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc45: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 1 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV1 2 254 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)254;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: ubTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: ubTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: ADDi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: uTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 1 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV2 2 65534 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)65534;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: uwTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asWORD;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: uwTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asWORD;
		l_bc += 1;
	}
	/* bytecode: ADDi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: uTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 -2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)4294967294;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDi 2 1 3 */
	bc13: {
		asINT32 lhs = ASEA_FRAME_VAR(1).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(3).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: uTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)1;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689202047582207 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073709551614;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDi64 4 2 6 */
	bc19: {
		asINT64 lhs = ASEA_FRAME_VAR(2).as_asINT64;
		asINT64 rhs = ASEA_FRAME_VAR(6).as_asINT64;
		ASEA_FRAME_VAR(4).as_asINT64 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 1 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV1 2 254 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)254;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: ADDi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV1 2 20 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: SUBi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs - rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV1 2 251 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)251;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: MULi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs * rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV1 2 254 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)254;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: DIVi 2 2 4 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 7 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)7;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV1 2 4 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)4;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: sbTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: MODi 2 2 4 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc22;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc13: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: INCi8 */
	bc14: {
		++ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: RDR1 2 */
	bc15: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 2 */
	bc16: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 4 2 */
	bc17: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc22;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc13: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: DECi8 */
	bc14: {
		--ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: RDR1 2 */
	bc15: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 2 */
	bc16: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 4 2 */
	bc17: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc15;
	case 4: goto bc26;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 0 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 1 0 */
	bc11: {
		int i1 = ASEA_FRAME_VAR(1).as_asINT32;
		int i2 = 0;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JS 14 */
	bc13: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += 16;
			goto bc29;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 3 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC8 1 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = 1;
		l_bc += 3;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc15;
	case 4: goto bc26;
	case 5: goto bc31;
	case 6: goto bc42;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 0 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 1 0 */
	bc11: {
		int i1 = ASEA_FRAME_VAR(1).as_asINT32;
		int i2 = 0;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JNS 16 */
	bc13: {
		if( regs->valueRegister.as_asINT64 >= 0 ) {
			l_bc += 18;
			goto bc31;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 3 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC8 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = 0;
		l_bc += 3;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 14 */
	bc29: {
		l_bc += 16;
		goto bc45;
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC8 1 */
	bc37: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = 1;
		l_bc += 3;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc45: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc16;
	case 4: goto bc27;
	case 5: goto bc32;
	case 6: goto bc43;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 1 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoR4 1 */
	bc13: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: JLowZ 16 */
	bc14: {
		if( regs->valueRegister.as_asBYTE == 0 ) {
			l_bc += 18;
			goto bc32;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 3 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236485992 */
	bc22: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 14 */
	bc30: {
		l_bc += 16;
		goto bc46;
	}
	/* bytecode: JitEntry 5 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236487144 */
	bc38: {
		extern void* asea_strobj1_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc29;
	case 4: goto bc40;
	case 5: goto bc45;
	case 6: goto bc56;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 1 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV1 2 0 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoR4 1 */
	bc17: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: JLowZ 4 */
	bc18: {
		if( regs->valueRegister.as_asBYTE == 0 ) {
			l_bc += 6;
			goto bc24;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: SetV1 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: JMP 2 */
	bc22: {
		l_bc += 4;
		goto bc26;
	}
	/* bytecode: CpyVtoV4 2 3 */
	bc24: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: CpyVtoR4 2 */
	bc26: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc++;
	}
	/* bytecode: JLowZ 16 */
	bc27: {
		if( regs->valueRegister.as_asBYTE == 0 ) {
			l_bc += 18;
			goto bc45;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 3 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236575464 */
	bc35: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 14 */
	bc43: {
		l_bc += 16;
		goto bc59;
	}
	/* bytecode: JitEntry 5 */
	bc45: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236576520 */
	bc51: {
		extern void* asea_strobj1_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit117_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshGPtr 137073828811240 */
	bc6: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS foo # void Base::foo() */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DIVu64 4 2 6 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)10;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MODu64 4 2 6 */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: uint8[]@ $list(int&in list) { repeat uint8 } */
void asea_jit125_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761033784576 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $list # T[]@ $list(int&in type, int&in list) { repeat T } */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: uint8[]@ $fact(uint length, const uint8&in value) */
void asea_jit124_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761033784576 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # uint8[]@ uint8[]::array(int&in, uint length, const uint8&in value) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: uint8[]@ $fact(uint length) */
void asea_jit123_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761033784576 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # uint8[]@ uint8[]::array(int&in, uint length) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: uint8[]@ $fact() */
void asea_jit122_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761033784576 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # uint8[]@ uint8[]::array(int&in) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/bfint.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/bfint.as:106:1: void main() */
void asea_jit117_module_scripts_2F_bfint_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236945064 */
	bc6: {
		extern void* asea_strobj0_asea_jit117_module_scripts_2F_bfint_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit117_module_scripts_2F_bfint_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL bf # void bf(const string&in source) */
	bc9: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/bfint.as:3:1: void bf(const string&in source) */
void asea_jit116_module_scripts_2F_bfint_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc14;
	case 4: goto bc19;
	case 5: goto bc24;
	case 6: goto bc30;
	case 7: goto bc36;
	case 8: goto bc45;
	case 9: goto bc58;
	case 10: goto bc66;
	case 11: goto bc73;
	case 12: goto bc120;
	case 13: goto bc130;
	case 14: goto bc134;
	case 15: goto bc139;
	case 16: goto bc149;
	case 17: goto bc153;
	case 18: goto bc158;
	case 19: goto bc168;
	case 20: goto bc175;
	case 21: goto bc183;
	case 22: goto bc193;
	case 23: goto bc202;
	case 24: goto bc210;
	case 25: goto bc215;
	case 26: goto bc224;
	case 27: goto bc237;
	case 28: goto bc243;
	case 29: goto bc253;
	case 30: goto bc262;
	case 31: goto bc272;
	case 32: goto bc279;
	case 33: goto bc286;
	case 34: goto bc294;
	case 35: goto bc300;
	case 36: goto bc305;
	case 37: goto bc315;
	case 38: goto bc324;
	case 39: goto bc332;
	case 40: goto bc337;
	case 41: goto bc346;
	case 42: goto bc359;
	case 43: goto bc365;
	case 44: goto bc375;
	case 45: goto bc384;
	case 46: goto bc394;
	case 47: goto bc401;
	case 48: goto bc408;
	case 49: goto bc416;
	case 50: goto bc422;
	case 51: goto bc427;
	case 52: goto bc434;
	case 53: goto bc439;
	case 54: goto bc446;
	case 55: goto bc451;
	case 56: goto bc457;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 30000 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 30000;
		l_bc += 2;
	}
	/* bytecode: CALL $fact # uint8[]@ $fact(uint length) */
	bc8: {
		extern char asea_script_fn123;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn123);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 4 0 */
	bc17: {
		ASEA_FRAME_VAR(4).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 5 0 */
	bc22: {
		ASEA_FRAME_VAR(5).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JitEntry 5 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS length # uint string::length() const */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 3 */
	bc33: {
		ASEA_FRAME_VAR(3).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: CpyVtoV4 6 3 */
	bc34: {
		ASEA_FRAME_VAR(6).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 7 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 3 1 */
	bc39: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoR4 3 */
	bc41: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc++;
	}
	/* bytecode: JLowZ 413 */
	bc42: {
		if( regs->valueRegister.as_asBYTE == 0 ) {
			l_bc += 415;
			goto bc457;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: SUSPEND */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 8 */
	bc45: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc51: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 5 6 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JNZ 8 */
	bc56: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 10;
			goto bc66;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 9 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 391 */
	bc64: {
		l_bc += 393;
		goto bc457;
	}
	/* bytecode: JitEntry 10 */
	bc66: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 5 */
	bc69: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(5).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 0 */
	bc70: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # const uint8& string::opIndex(uint) const */
	bc71: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR1 3 */
	bc76: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: ubTOi 3 */
	bc77: {
		ASEA_FRAME_VAR(3).as_asINT32 = ASEA_FRAME_VAR(3).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CMPIi 3 93 */
	bc78: {
		int i1 = ASEA_FRAME_VAR(3).as_asINT32;
		int i2 = 93;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JP 369 */
	bc80: {
		if( regs->valueRegister.as_asINT64 > 0 ) {
			l_bc += 371;
			goto bc451;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: CMPIi 3 43 */
	bc82: {
		int i1 = ASEA_FRAME_VAR(3).as_asINT32;
		int i2 = 43;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JS 365 */
	bc84: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += 367;
			goto bc451;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: CMPIi 3 46 */
	bc86: {
		int i1 = ASEA_FRAME_VAR(3).as_asINT32;
		int i2 = 46;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JP 12 */
	bc88: {
		if( regs->valueRegister.as_asINT64 > 0 ) {
			l_bc += 14;
			goto bc102;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: SUBIi 7 3 43 */
	bc90: {
		asINT32 lhs = ASEA_FRAME_VAR(3).as_asINT32;
		ASEA_FRAME_VAR(7).as_asINT32 = lhs - (43);
		l_bc += 3;
	}
	/* bytecode: JMPP 7 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP 24 */
	bc94: {
		l_bc += 26;
		goto bc120;
	}
	/* bytecode: JMP 353 */
	bc96: {
		l_bc += 355;
		goto bc451;
	}
	/* bytecode: JMP 39 */
	bc98: {
		l_bc += 41;
		goto bc139;
	}
	/* bytecode: JMP 56 */
	bc100: {
		l_bc += 58;
		goto bc158;
	}
	/* bytecode: CMPIi 3 60 */
	bc102: {
		int i1 = ASEA_FRAME_VAR(3).as_asINT32;
		int i2 = 60;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JZ 321 */
	bc104: {
		if( regs->valueRegister.as_asINT64 == 0 ) {
			l_bc += 323;
			goto bc427;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: CMPIi 3 62 */
	bc106: {
		int i1 = ASEA_FRAME_VAR(3).as_asINT32;
		int i2 = 62;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JZ 329 */
	bc108: {
		if( regs->valueRegister.as_asINT64 == 0 ) {
			l_bc += 331;
			goto bc439;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: CMPIi 3 91 */
	bc110: {
		int i1 = ASEA_FRAME_VAR(3).as_asINT32;
		int i2 = 91;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JZ 69 */
	bc112: {
		if( regs->valueRegister.as_asINT64 == 0 ) {
			l_bc += 71;
			goto bc183;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: CMPIi 3 93 */
	bc114: {
		int i1 = ASEA_FRAME_VAR(3).as_asINT32;
		int i2 = 93;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JZ 187 */
	bc116: {
		if( regs->valueRegister.as_asINT64 == 0 ) {
			l_bc += 189;
			goto bc305;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JMP 331 */
	bc118: {
		l_bc += 333;
		goto bc451;
	}
	/* bytecode: JitEntry 12 */
	bc120: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc123: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 4 */
	bc126: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(4).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc127: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # uint8& uint8[]::opIndex(uint index) */
	bc128: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc130: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: INCi8 */
	bc133: {
		++ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: JitEntry 14 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 312 */
	bc137: {
		l_bc += 314;
		goto bc451;
	}
	/* bytecode: JitEntry 15 */
	bc139: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc142: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 4 */
	bc145: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(4).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc146: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # uint8& uint8[]::opIndex(uint index) */
	bc147: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc149: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DECi8 */
	bc152: {
		--ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: JitEntry 17 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 293 */
	bc156: {
		l_bc += 295;
		goto bc451;
	}
	/* bytecode: JitEntry 18 */
	bc158: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc161: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 4 */
	bc164: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(4).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc165: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # uint8& uint8[]::opIndex(uint index) */
	bc166: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc168: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR1 7 */
	bc171: {
		asea_var* var = &ASEA_FRAME_VAR(7);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc172: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS putchar # void putchar(uint8) */
	bc173: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc175: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc178: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 268 */
	bc181: {
		l_bc += 270;
		goto bc451;
	}
	/* bytecode: JitEntry 21 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 4 */
	bc189: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(4).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc190: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # uint8& uint8[]::opIndex(uint index) */
	bc191: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 22 */
	bc193: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR1 3 */
	bc196: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: ubTOi 3 */
	bc197: {
		ASEA_FRAME_VAR(3).as_asINT32 = ASEA_FRAME_VAR(3).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CMPIu 3 0 */
	bc198: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JZ 8 */
	bc200: {
		if( regs->valueRegister.as_asINT64 == 0 ) {
			l_bc += 10;
			goto bc210;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 23 */
	bc202: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc205: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 241 */
	bc208: {
		l_bc += 243;
		goto bc451;
	}
	/* bytecode: JitEntry 24 */
	bc210: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 8 0 */
	bc213: {
		ASEA_FRAME_VAR(8).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JitEntry 25 */
	bc215: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 3 1 */
	bc218: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoR4 3 */
	bc220: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc++;
	}
	/* bytecode: JLowZ 77 */
	bc221: {
		if( regs->valueRegister.as_asBYTE == 0 ) {
			l_bc += 79;
			goto bc300;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: SUSPEND */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 26 */
	bc224: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc227: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc230: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 5 */
	bc233: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(5).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 0 */
	bc234: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # const uint8& string::opIndex(uint) const */
	bc235: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 27 */
	bc237: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR1 7 */
	bc240: {
		asea_var* var = &ASEA_FRAME_VAR(7);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: CpyVtoV4 9 7 */
	bc241: {
		ASEA_FRAME_VAR(9).as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 28 */
	bc243: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 3 9 */
	bc246: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: ubTOi 3 */
	bc248: {
		ASEA_FRAME_VAR(3).as_asINT32 = ASEA_FRAME_VAR(3).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CMPIu 3 91 */
	bc249: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JNZ 9 */
	bc251: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 11;
			goto bc262;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 29 */
	bc253: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc256: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 8 */
	bc259: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP 17 */
	bc260: {
		l_bc += 19;
		goto bc279;
	}
	/* bytecode: JitEntry 30 */
	bc262: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 7 9 */
	bc265: {
		ASEA_FRAME_VAR(7).as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: ubTOi 7 */
	bc267: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(7).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CMPIu 7 93 */
	bc268: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JNZ 7 */
	bc270: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 9;
			goto bc279;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 31 */
	bc272: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc275: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DecVi 8 */
	bc278: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 32 */
	bc279: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 8 0 */
	bc282: {
		int i1 = ASEA_FRAME_VAR(8).as_asINT32;
		int i2 = 0;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JNZ 8 */
	bc284: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 10;
			goto bc294;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 33 */
	bc286: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc289: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 6 */
	bc292: {
		l_bc += 8;
		goto bc300;
	}
	/* bytecode: JitEntry 34 */
	bc294: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 5 */
	bc297: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP -82 */
	bc298: {
		l_bc += -80;
		goto bc218;
	}
	/* bytecode: JitEntry 35 */
	bc300: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 146 */
	bc303: {
		l_bc += 148;
		goto bc451;
	}
	/* bytecode: JitEntry 36 */
	bc305: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc308: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 4 */
	bc311: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(4).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc312: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # uint8& uint8[]::opIndex(uint index) */
	bc313: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 37 */
	bc315: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR1 3 */
	bc318: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: ubTOi 3 */
	bc319: {
		ASEA_FRAME_VAR(3).as_asINT32 = ASEA_FRAME_VAR(3).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CMPIu 3 0 */
	bc320: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JNZ 8 */
	bc322: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 10;
			goto bc332;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 38 */
	bc324: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc327: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 119 */
	bc330: {
		l_bc += 121;
		goto bc451;
	}
	/* bytecode: JitEntry 39 */
	bc332: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 8 0 */
	bc335: {
		ASEA_FRAME_VAR(8).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JitEntry 40 */
	bc337: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 7 1 */
	bc340: {
		ASEA_FRAME_VAR(7).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoR4 7 */
	bc342: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		l_bc++;
	}
	/* bytecode: JLowZ 77 */
	bc343: {
		if( regs->valueRegister.as_asBYTE == 0 ) {
			l_bc += 79;
			goto bc422;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: SUSPEND */
	bc345: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 41 */
	bc346: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc349: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc352: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 5 */
	bc355: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(5).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 0 */
	bc356: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # const uint8& string::opIndex(uint) const */
	bc357: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 42 */
	bc359: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR1 3 */
	bc362: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: CpyVtoV4 9 3 */
	bc363: {
		ASEA_FRAME_VAR(9).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 43 */
	bc365: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 7 9 */
	bc368: {
		ASEA_FRAME_VAR(7).as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: ubTOi 7 */
	bc370: {
		ASEA_FRAME_VAR(7).as_asINT32 = ASEA_FRAME_VAR(7).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CMPIu 7 91 */
	bc371: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JNZ 9 */
	bc373: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 11;
			goto bc384;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 44 */
	bc375: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc378: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 8 */
	bc381: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP 17 */
	bc382: {
		l_bc += 19;
		goto bc401;
	}
	/* bytecode: JitEntry 45 */
	bc384: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 3 9 */
	bc387: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: ubTOi 3 */
	bc389: {
		ASEA_FRAME_VAR(3).as_asINT32 = ASEA_FRAME_VAR(3).as_asBYTE;
		l_bc += 1;
	}
	/* bytecode: CMPIu 3 93 */
	bc390: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JNZ 7 */
	bc392: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 9;
			goto bc401;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 46 */
	bc394: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc397: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DecVi 8 */
	bc400: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 47 */
	bc401: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 8 0 */
	bc404: {
		int i1 = ASEA_FRAME_VAR(8).as_asINT32;
		int i2 = 0;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JNZ 8 */
	bc406: {
		if( regs->valueRegister.as_asINT64 != 0 ) {
			l_bc += 10;
			goto bc416;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 48 */
	bc408: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc411: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 6 */
	bc414: {
		l_bc += 8;
		goto bc422;
	}
	/* bytecode: JitEntry 49 */
	bc416: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DecVi 5 */
	bc419: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP -82 */
	bc420: {
		l_bc += -80;
		goto bc340;
	}
	/* bytecode: JitEntry 50 */
	bc422: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 24 */
	bc425: {
		l_bc += 26;
		goto bc451;
	}
	/* bytecode: JitEntry 51 */
	bc427: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc430: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DecVi 4 */
	bc433: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 52 */
	bc434: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 12 */
	bc437: {
		l_bc += 14;
		goto bc451;
	}
	/* bytecode: JitEntry 53 */
	bc439: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc442: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 4 */
	bc445: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 54 */
	bc446: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 0 */
	bc449: {
		l_bc += 2;
		goto bc451;
	}
	/* bytecode: JitEntry 55 */
	bc451: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 5 */
	bc454: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP -418 */
	bc455: {
		l_bc += -416;
		goto bc39;
	}
	/* bytecode: JitEntry 56 */
	bc457: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 562992903126346 */
	bc460: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc463: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc28;
	case 5: goto bc34;
	case 6: goto bc40;
	case 7: goto bc46;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 -123 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4294967173;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237980712 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOf 2 */
	bc22: {
		ASEA_FRAME_VAR(2).as_float = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 1;
	}
	/* bytecode: PshV4 2 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc30;
	case 5: goto bc36;
	case 6: goto bc42;
	case 7: goto bc48;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 -1024005767 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)3270961529;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237947688 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: fTOi 2 */
	bc22: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_float;
		l_bc += 1;
	}
	/* bytecode: iTOi64 12 2 */
	bc23: {
		ASEA_FRAME_VAR(12).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 12 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(12).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc51: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc28;
	case 5: goto bc34;
	case 6: goto bc40;
	case 7: goto bc46;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 123 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237840648 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: uTOf 2 */
	bc22: {
		ASEA_FRAME_VAR(2).as_float = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 1;
	}
	/* bytecode: PshV4 2 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc30;
	case 5: goto bc36;
	case 6: goto bc42;
	case 7: goto bc48;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1123477881 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1123477881;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237810312 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: fTOu 2 */
	bc22: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(2).as_float;
		l_bc += 1;
	}
	/* bytecode: uTOi64 12 2 */
	bc23: {
		ASEA_FRAME_VAR(12).as_asINT64 = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 12 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(12).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(uint64) const */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc51: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 -123 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)4294967173;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237679560 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOd 4 2 */
	bc22: {
		ASEA_FRAME_VAR(4).as_double = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc34;
	case 5: goto bc40;
	case 6: goto bc46;
	case 7: goto bc52;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563301073214767 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)13861759897472843383;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237550728 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: dTOi 5 4 */
	bc25: {
		ASEA_FRAME_VAR(5).as_asINT32 = ASEA_FRAME_VAR(4).as_double;
		l_bc += 2;
	}
	/* bytecode: iTOi64 15 5 */
	bc27: {
		ASEA_FRAME_VAR(15).as_asINT64 = ASEA_FRAME_VAR(5).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 15 */
	bc29: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(15).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 13 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 123 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237426408 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: uTOd 4 2 */
	bc22: {
		ASEA_FRAME_VAR(4).as_double = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc34;
	case 5: goto bc40;
	case 6: goto bc46;
	case 7: goto bc52;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298925731119 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4638387860618067575;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237285192 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: dTOu 5 4 */
	bc25: {
		ASEA_FRAME_VAR(5).as_asDWORD = ASEA_FRAME_VAR(4).as_double;
		l_bc += 2;
	}
	/* bytecode: uTOi64 15 5 */
	bc27: {
		ASEA_FRAME_VAR(15).as_asINT64 = ASEA_FRAME_VAR(5).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 15 */
	bc29: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(15).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 13 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(uint64) const */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 -1024005767 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)3270961529;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237161160 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: fTOi64 4 2 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_float;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563301073214767 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)13861759897472843383;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237017640 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: dTOi64 4 */
	bc25: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(4).as_double;
		l_bc += 1;
	}
	/* bytecode: PshV8 4 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc29;
	case 5: goto bc35;
	case 6: goto bc41;
	case 7: goto bc47;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1123477881 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1123477881;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239075784 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc20: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: fTOu64 4 2 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_float;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(uint64) const */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298925731119 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4638387860618067575;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239008008 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: dTOu64 4 */
	bc25: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(4).as_double;
		l_bc += 1;
	}
	/* bytecode: PshV8 4 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(uint64) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563302140739583 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073709551493;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238795176 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOf 5 4 */
	bc25: {
		ASEA_FRAME_VAR(5).as_float = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 2;
	}
	/* bytecode: PshV4 5 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(5).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 21 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 13 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 21 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 21 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc32;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)123;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238711080 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: u64TOf 5 4 */
	bc25: {
		ASEA_FRAME_VAR(5).as_float = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: PshV4 5 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(5).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 21 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 13 */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 13 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 21 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 21 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563302140739583 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)18446744073709551493;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238576488 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: i64TOd 4 */
	bc25: {
		ASEA_FRAME_VAR(4).as_double = ASEA_FRAME_VAR(4).as_asINT64;
		l_bc += 1;
	}
	/* bytecode: PshV8 4 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)123;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238445736 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: u64TOd 4 */
	bc25: {
		ASEA_FRAME_VAR(4).as_double = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 1;
	}
	/* bytecode: PshV8 4 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238318344 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238330248 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238298472 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238165896 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239150568 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239932200 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240030504 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240136968 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240247464 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240353928 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240460392 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240570984 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240677448 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730240775752 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243901800 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243180648 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242566056 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242676552 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPu 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/typedefs.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/typedefs.as:8:1: void main() */
void asea_jit116_module_scripts_2F_typedefs_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc17;
	case 4: goto bc25;
	case 5: goto bc31;
	case 6: goto bc37;
	case 7: goto bc43;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1078527525 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1078527525;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242781288 */
	bc11: {
		extern void* asea_strobj0_asea_jit116_module_scripts_2F_typedefs_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_scripts_2F_typedefs_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 1 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(float) const */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242876424 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242995944 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730243107304 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242356200 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242273736 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231800904 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232283016 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232163304 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232051752 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231932040 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231808200 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232505544 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244848936 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244972488 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245092008 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)16;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245207016 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233569416 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc37;
	case 5: goto bc43;
	case 6: goto bc49;
	case 7: goto bc55;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563297845772288 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)15;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689197752614912 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)14;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730246270024 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi64 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc30: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 7 */
	bc31: {
		ASEA_FRAME_VAR(7).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 7 */
	bc32: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(7).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 23 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 15 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 15 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 23 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc55: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/refprimitives.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/refprimitives.as:8:1: void main() */
void asea_jit117_module_scripts_2F_refprimitives_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc18;
	case 4: goto bc23;
	case 5: goto bc33;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 123 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: VAR 2 */
	bc11: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)2;
		l_bc++;
	}
	/* bytecode: SetV4 3 10 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: PSF 3 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: GETREF 2 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL calc # void calc(int&in a, int&out b) */
	bc16: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 3 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc21: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 4 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 3 1 */
	bc26: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 3 */
	bc28: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(3).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/refprimitives.as:3:1: void calc(int&in a, int&out b) */
void asea_jit116_module_scripts_2F_refprimitives_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PopRPtr */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc8: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshVPtr -2 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PopRPtr */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 4 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)4;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DIVu 2 1 3 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: uTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 4 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)4;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MODu 2 1 3 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: uTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(uint64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/arrays/simple.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/simple.as:1:1: void main() */
void asea_jit116_module_scripts_2F_arrays_2F_simple_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc17;
	case 5: goto bc21;
	case 6: goto bc31;
	case 7: goto bc43;
	case 8: goto bc54;
	case 9: goto bc63;
	case 10: goto bc74;
	case 11: goto bc81;
	case 12: goto bc87;
	case 13: goto bc93;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL $fact # int[]@ $fact() */
	bc6: {
		extern char asea_script_fn121;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn121);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL $fact # string[]@ $fact() */
	bc15: {
		extern char asea_script_fn161;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn161);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 4 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 5 123 */
	bc24: {
		ASEA_FRAME_VAR(5).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: VAR 5 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)5;
		l_bc++;
	}
	/* bytecode: PshVPtr 2 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: GETREF 2 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS insertLast # void int[]::insertLast(const int&in value) */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245932872 */
	bc37: {
		extern void* asea_strobj0_asea_jit116_module_scripts_2F_arrays_2F_simple_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_scripts_2F_arrays_2F_simple_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 4 */
	bc40: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS insertLast # void string[]::insertLast(const string&in value) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 0 */
	bc49: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 0;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 2 */
	bc51: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # int& int[]::opIndex(uint index) */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc54: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RDR4 6 */
	bc57: {
		asea_var* var = &ASEA_FRAME_VAR(6);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 8 6 */
	bc58: {
		ASEA_FRAME_VAR(8).as_asINT64 = ASEA_FRAME_VAR(6).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 8 */
	bc60: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(8).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc66: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 0 */
	bc69: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 0;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 4 */
	bc71: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # string& string[]::opIndex(uint index) */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc74: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshRPtr */
	bc77: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 16 */
	bc78: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc79: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc81: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc84: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc85: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc87: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 16 */
	bc90: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc91: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 4 563229126327626 */
	bc99: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc105: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $list(int&in list) { repeat string } */
void asea_jit164_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024928256 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $list # T[]@ $list(int&in type, int&in list) { repeat T } */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $fact(uint length, const string&in value) */
void asea_jit163_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024928256 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # string[]@ string[]::array(int&in, uint length, const string&in value) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $fact(uint length) */
void asea_jit162_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024928256 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # string[]@ string[]::array(int&in, uint length) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: string[]@ $fact() */
void asea_jit161_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024928256 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # string[]@ string[]::array(int&in) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $list(int&in list) { repeat int } */
void asea_jit124_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024926976 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $list # T[]@ $list(int&in type, int&in list) { repeat T } */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $fact(uint length, const int&in value) */
void asea_jit123_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024926976 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # int[]@ int[]::array(int&in, uint length, const int&in value) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $fact(uint length) */
void asea_jit122_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024926976 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # int[]@ int[]::array(int&in, uint length) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: int[]@ $fact() */
void asea_jit121_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761024926976 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # int[]@ int[]::array(int&in) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: a */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/sharedfuncs.as:3:1: int calc(int a, int b) */
void asea_jit116_module_a(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MULi 1 0 -1 */
	bc6: {
		asINT32 lhs = ASEA_FRAME_VAR(0).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(-1).as_asINT32;
		ASEA_FRAME_VAR(1).as_asINT32 = lhs * rhs;
		l_bc += 2;
	}
	/* bytecode: CpyVtoR4 1 */
	bc8: {
		regs->valueRegister.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: RET 2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/sharedfuncs.as:8:1: void main() */
void asea_jit117_module_a(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 2;
		l_bc += 2;
	}
	/* bytecode: PshC4 5 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 5;
		l_bc += 2;
	}
	/* bytecode: CALL calc # int calc(int a, int b) */
	bc10: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 3 */
	bc15: {
		ASEA_FRAME_VAR(3).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 5 3 */
	bc16: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(3).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc18: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: b */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/sharedfuncs.as:8:1: void main() */
void asea_jit118_module_b(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc21;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 2;
		l_bc += 2;
	}
	/* bytecode: PshC4 5 */
	bc8: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 5;
		l_bc += 2;
	}
	/* bytecode: CALL calc # int calc(int a, int b) */
	bc10: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 3 */
	bc15: {
		ASEA_FRAME_VAR(3).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 5 3 */
	bc16: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(3).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc18: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc19: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $list(int&in list) { repeat Foo } */
void asea_jit128_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761030077056 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $list # T[]@ $list(int&in type, int&in list) { repeat T } */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $fact(uint length, const Foo&in value) */
void asea_jit127_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761030077056 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # Foo[]@ Foo[]::array(int&in, uint length, const Foo&in value) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 3 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $fact(uint length) */
void asea_jit126_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761030077056 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # Foo[]@ Foo[]::array(int&in, uint length) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: <anon> */ 
/* <anon>:0:0: Foo[]@ $fact() */
void asea_jit125_anon(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: OBJTYPE 137761030077056 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh3 # Foo[]@ Foo[]::array(int&in) */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/arrays/userclass.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/userclass.as:4:5: Foo@ Foo(int a) */
void asea_jit120_module_scripts_2F_arrays_2F_userclass_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(0).as_asDWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761030074496 119 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 1 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/userclass.as:4:5: Foo::Foo(int a) */
void asea_jit119_module_scripts_2F_arrays_2F_userclass_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 -2 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 3 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/userclass.as:3:5: Foo@ Foo() */
void asea_jit118_module_scripts_2F_arrays_2F_userclass_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761030074496 117 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/userclass.as:9:1: void main() */
void asea_jit116_module_scripts_2F_arrays_2F_userclass_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc29;
	case 6: goto bc35;
	case 7: goto bc42;
	case 8: goto bc52;
	case 9: goto bc58;
	case 10: goto bc65;
	case 11: goto bc75;
	case 12: goto bc81;
	case 13: goto bc92;
	case 14: goto bc105;
	case 15: goto bc118;
	case 16: goto bc125;
	case 17: goto bc131;
	case 18: goto bc139;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL $fact # Foo[]@ $fact() */
	bc6: {
		extern char asea_script_fn125;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn125);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 123 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: CALL Foo # Foo@ Foo(int a) */
	bc17: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 5 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 5 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 5 */
	bc24: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)5;
		l_bc++;
	}
	/* bytecode: PshVPtr 2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: GETOBJREF 2 */
	bc26: {
		asPWORD *dst = &ASEA_STACK_VAR(2).as_asPWORD;
		asPWORD var_idx = *dst;
		asPWORD var_addr = ASEA_FRAME_VAR(var_idx).as_asPWORD;
		ASEA_STACK_VAR(2).as_asPWORD = var_addr;
		l_bc++;
	}
	/* bytecode: CALLSYS insertLast # void Foo[]::insertLast(const Foo&in value) */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 5 751619308874 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 456 */
	bc38: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: CALL Foo # Foo@ Foo(int a) */
	bc40: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 7 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 5 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 5 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 5 */
	bc47: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)5;
		l_bc++;
	}
	/* bytecode: PshVPtr 2 */
	bc48: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: GETOBJREF 2 */
	bc49: {
		asPWORD *dst = &ASEA_STACK_VAR(2).as_asPWORD;
		asPWORD var_idx = *dst;
		asPWORD var_addr = ASEA_FRAME_VAR(var_idx).as_asPWORD;
		ASEA_STACK_VAR(2).as_asPWORD = var_addr;
		l_bc++;
	}
	/* bytecode: CALLSYS insertLast # void Foo[]::insertLast(const Foo&in value) */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 5 751619308874 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc58: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc61: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: CALL Foo # Foo@ Foo(int a) */
	bc63: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 10 */
	bc65: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 5 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ChkNullV 5 */
	bc69: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 5 */
	bc70: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)5;
		l_bc++;
	}
	/* bytecode: PshVPtr 2 */
	bc71: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: GETOBJREF 2 */
	bc72: {
		asPWORD *dst = &ASEA_STACK_VAR(2).as_asPWORD;
		asPWORD var_idx = *dst;
		asPWORD var_addr = ASEA_FRAME_VAR(var_idx).as_asPWORD;
		ASEA_STACK_VAR(2).as_asPWORD = var_addr;
		l_bc++;
	}
	/* bytecode: CALLSYS insertLast # void Foo[]::insertLast(const Foo&in value) */
	bc73: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc75: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 5 751619308874 */
	bc78: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc81: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc84: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 6 0 */
	bc87: {
		ASEA_FRAME_VAR(6).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JMP 34 */
	bc89: {
		l_bc += 36;
		goto bc125;
	}
	/* bytecode: SUSPEND */
	bc91: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 13 */
	bc92: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc95: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc98: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV4 6 */
	bc101: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(6).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 2 */
	bc102: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: Thiscall1 opIndex # Foo& Foo[]::opIndex(uint index) */
	bc103: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc105: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshRPtr */
	bc108: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ADDSi 32 134217742 */
	bc109: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc111: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc112: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 8 3 */
	bc113: {
		ASEA_FRAME_VAR(8).as_asINT64 = ASEA_FRAME_VAR(3).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 8 */
	bc115: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(8).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc116: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc118: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc121: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 6 */
	bc124: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc125: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc128: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS length # uint Foo[]::length() const */
	bc129: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc131: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyRtoV4 3 */
	bc134: {
		ASEA_FRAME_VAR(3).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: CMPu 6 3 */
	bc135: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JS -48 */
	bc137: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += -46;
			goto bc91;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 18 */
	bc139: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc142: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc145: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/arrays/userclass.as:3:5: Foo::Foo() */
void asea_jit117_module_scripts_2F_arrays_2F_userclass_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	case 4: goto bc37;
	case 5: goto bc44;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc6: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 0 */
	bc9: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: JMP 24 */
	bc11: {
		l_bc += 26;
		goto bc37;
	}
	/* bytecode: SUSPEND */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc17: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc23: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 4 2 */
	bc25: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 1 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 1 5 */
	bc40: {
		int i1 = ASEA_FRAME_VAR(1).as_asINT32;
		int i2 = 5;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JS -31 */
	bc42: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += -29;
			goto bc13;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: JitEntry 5 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233123112 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233285064 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233442504 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value > 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231407208 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235648968 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235686408 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value >= 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233742504 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233896488 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730233975208 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TS */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234052488 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234193416 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234269736 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNP */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value < 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234402120 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245651976 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245752584 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value == 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 16 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)16;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236519400 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 15 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236463336 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 15 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)15;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 14 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)14;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234918888 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPi 1 3 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: TNZ */
	bc24: {
		asINT32 value = regs->valueRegister.as_asINT32;
		regs->valueRegister.as_asQWORD = 0;
		regs->valueRegister.as_asBYTE = (value != 0) ? VALUE_OF_BOOLEAN_TRUE : 0;
		l_bc++;
	}
	/* bytecode: CpyRtoV4 2 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = regs->valueRegister.as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 11 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 11 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/devirt.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: B@ B(const B&inout other) */
void asea_jit125_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761030301696 124 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: B::B() */
void asea_jit122_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc6;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc3: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALL A # A::A() */
	bc4: {
		extern char asea_script_fn118;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn118);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc6: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: B::B(const B&inout other) */
void asea_jit124_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc7;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr -2 */
	bc3: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALL A # A::A(const A&inout other) */
	bc5: {
		extern char asea_script_fn120;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn120);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc7: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: A::A(const A&inout other) */
void asea_jit120_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: B@ B() */
void asea_jit123_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761030301696 122 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: A@ A() */
void asea_jit119_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761030304256 118 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: A::A() */
void asea_jit118_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:0:0: A@ A(const A&inout other) */
void asea_jit121_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761030304256 120 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:5:5: void A::foo() */
void asea_jit117_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235076232 */
	bc6: {
		extern void* asea_strobj0_asea_jit117_module_scripts_2F_devirt_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit117_module_scripts_2F_devirt_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/devirt.as:13:1: void main() */
void asea_jit116_module_scripts_2F_devirt_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc15;
	case 4: goto bc21;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL B # B@ B() */
	bc6: {
		extern char asea_script_fn123;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn123);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 2 */
	bc12: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 126 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 751619308874 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc28;
	case 5: goto bc34;
	case 6: goto bc40;
	case 7: goto bc46;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298920112324 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4614255322014802772;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235240776 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV8 2 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc46: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc35;
	case 5: goto bc41;
	case 6: goto bc47;
	case 7: goto bc53;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298918465536 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4607182418800017408;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198826356736 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235322472 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDd 4 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 22 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 14 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc59: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc35;
	case 5: goto bc41;
	case 6: goto bc47;
	case 7: goto bc53;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298918465536 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4607182418800017408;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198826356736 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235432968 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SUBd 4 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 22 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 14 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc59: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc35;
	case 5: goto bc41;
	case 6: goto bc47;
	case 7: goto bc53;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298920824832 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4617315517961601024;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198826356736 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235636488 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MULd 4 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 22 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 14 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc59: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc35;
	case 5: goto bc41;
	case 6: goto bc47;
	case 7: goto bc53;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298920824832 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4617315517961601024;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198826356736 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730231728616 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DIVd 4 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 22 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 14 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc59: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc16;
	case 3: goto bc25;
	case 4: goto bc35;
	case 5: goto bc41;
	case 6: goto bc47;
	case 7: goto bc53;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298921873408 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4621819117588971520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: SetV8 4 1689198827929600 */
	bc11: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4618441417868443648;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 6 4 */
	bc14: {
		ASEA_FRAME_VAR(6).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730245255880 */
	bc19: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MODd 4 2 6 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc30: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 22 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 14 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 14 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc47: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 22 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc59: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298921873408 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4621819117588971520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238015080 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV8 4 2 */
	bc23: {
		ASEA_FRAME_VAR(4).as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: NEGd 4 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV8 4 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	case 8: goto bc56;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298918465536 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4607182418800017408;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 1126437851496448 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: ADDd 4 2 4 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234773544 */
	bc24: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV8 2 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	case 8: goto bc56;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298918465536 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4607182418800017408;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 1126442146463744 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: SUBd 4 2 4 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236277288 */
	bc24: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV8 2 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	case 8: goto bc56;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298920824832 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4617315517961601024;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 1126446441431040 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: MULd 4 2 4 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236162568 */
	bc24: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV8 2 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	case 8: goto bc56;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298920824832 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4617315517961601024;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 1126450736398336 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4611686018427387904;
		l_bc += 3;
	}
	/* bytecode: DIVd 4 2 4 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235973544 */
	bc24: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV8 2 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc21;
	case 4: goto bc30;
	case 5: goto bc38;
	case 6: goto bc44;
	case 7: goto bc50;
	case 8: goto bc56;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298921873408 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4621819117588971520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 1126455032938496 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4618441417868443648;
		l_bc += 3;
	}
	/* bytecode: MODd 4 2 4 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 3 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236076744 */
	bc24: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshV8 2 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(2).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc38: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc48: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc50: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc56: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc59: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298921873408 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4621819117588971520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730235869288 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 2 */
	bc23: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc++;
	}
	/* bytecode: INCd */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 4 */
	bc25: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 4 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc20;
	case 4: goto bc31;
	case 5: goto bc37;
	case 6: goto bc43;
	case 7: goto bc49;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 4 563298921873408 */
	bc6: {
		ASEA_FRAME_VAR(4).as_asQWORD = (asQWORD)4621819117588971520;
		l_bc += 3;
	}
	/* bytecode: CpyVtoV8 2 4 */
	bc9: {
		ASEA_FRAME_VAR(2).as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730234884232 */
	bc14: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 2 */
	bc23: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc++;
	}
	/* bytecode: DECd */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 4 */
	bc25: {
		asea_var* var = &ASEA_FRAME_VAR(4);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 4 */
	bc26: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 20 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 12 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(double) const */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 12 */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc37: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 20 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/globalswithclasses.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/globalswithclasses.as:0:0: Foo@ Foo(const Foo&inout other) */
void asea_jit121_module_scripts_2F_globalswithclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761034055296 120 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/globalswithclasses.as:0:0: Foo::Foo(const Foo&inout other) */
void asea_jit120_module_scripts_2F_globalswithclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/globalswithclasses.as:0:0: Foo@ Foo() */
void asea_jit119_module_scripts_2F_globalswithclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761034055296 118 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/globalswithclasses.as:0:0: Foo::Foo() */
void asea_jit118_module_scripts_2F_globalswithclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/globalswithclasses.as:13:1: void global_test() */
void asea_jit117_module_scripts_2F_globalswithclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc27;
	case 4: goto bc39;
	case 5: goto bc68;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 123 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)123;
		l_bc += 2;
	}
	/* bytecode: PshGPtr 137073828998000 */
	bc8: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDSi 32 134217742 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc14: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 456 */
	bc18: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)456;
		l_bc += 2;
	}
	/* bytecode: PshGPtr 137073828998000 */
	bc20: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDSi 36 134217742 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 789 */
	bc30: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)789;
		l_bc += 2;
	}
	/* bytecode: PshGPtr 137073828998000 */
	bc32: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDSi 40 134217742 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshGPtr 137073828998000 */
	bc42: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDSi 40 134217742 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc47: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc48: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 1 */
	bc49: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshGPtr 137073828998000 */
	bc50: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDSi 36 134217742 */
	bc53: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc55: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 2 */
	bc56: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 2 */
	bc57: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PshGPtr 137073828998000 */
	bc58: {
		extern void* asea_global0;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)asea_global0;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDSi 32 134217742 */
	bc61: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopRPtr */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 3 */
	bc64: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: PshV4 3 */
	bc65: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		++l_bc;
	}
	/* bytecode: CALL bar # void bar(int a, int b, int c) */
	bc66: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/globalswithclasses.as:5:1: void bar(int a, int b, int c) */
void asea_jit116_module_scripts_2F_globalswithclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc12;
	case 3: goto bc24;
	case 4: goto bc30;
	case 5: goto bc36;
	case 6: goto bc42;
	case 7: goto bc54;
	case 8: goto bc66;
	case 9: goto bc72;
	case 10: goto bc78;
	case 11: goto bc84;
	case 12: goto bc96;
	case 13: goto bc108;
	case 14: goto bc114;
	case 15: goto bc120;
	case 16: goto bc126;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236409288 */
	bc6: {
		extern void* asea_strobj0_asea_jit116_module_scripts_2F_globalswithclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_scripts_2F_globalswithclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 9 0 */
	bc15: {
		ASEA_FRAME_VAR(9).as_asDWORD = ASEA_FRAME_VAR(0).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 11 9 */
	bc17: {
		ASEA_FRAME_VAR(11).as_asINT64 = ASEA_FRAME_VAR(9).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 11 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(11).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc45: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236409288 */
	bc48: {
		extern void* asea_strobj1_asea_jit116_module_scripts_2F_globalswithclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit116_module_scripts_2F_globalswithclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc54: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 9 -1 */
	bc57: {
		ASEA_FRAME_VAR(9).as_asDWORD = ASEA_FRAME_VAR(-1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 11 9 */
	bc59: {
		ASEA_FRAME_VAR(11).as_asINT64 = ASEA_FRAME_VAR(9).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 11 */
	bc61: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(11).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc63: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc64: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc66: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc69: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc72: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc75: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc78: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc81: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc84: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc87: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730236409288 */
	bc90: {
		extern void* asea_strobj2_asea_jit116_module_scripts_2F_globalswithclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit116_module_scripts_2F_globalswithclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc93: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc94: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 9 -2 */
	bc99: {
		ASEA_FRAME_VAR(9).as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 11 9 */
	bc101: {
		ASEA_FRAME_VAR(11).as_asINT64 = ASEA_FRAME_VAR(9).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 11 */
	bc103: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(11).as_asQWORD;
		++l_bc;
	}
	/* bytecode: PSF 19 */
	bc104: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc105: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(int64) const */
	bc106: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc108: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc111: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc114: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc117: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc120: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 19 */
	bc123: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc124: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc126: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc129: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 3 */
	bc132: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/switch.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/switch.as:50:1: void main() */
void asea_jit117_module_scripts_2F_switch_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 2 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 2;
		l_bc += 2;
	}
	/* bytecode: CALL switch_test # void switch_test(int i) */
	bc8: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 30 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 30;
		l_bc += 2;
	}
	/* bytecode: CALL switch_test # void switch_test(int i) */
	bc18: {
		extern char asea_script_fn116;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn116);
		return;
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/switch.as:3:1: void switch_test(int i) */
void asea_jit116_module_scripts_2F_switch_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc30;
	case 3: goto bc41;
	case 4: goto bc49;
	case 5: goto bc60;
	case 6: goto bc68;
	case 7: goto bc79;
	case 8: goto bc93;
	case 9: goto bc101;
	case 10: goto bc112;
	case 11: goto bc120;
	case 12: goto bc131;
	case 13: goto bc139;
	case 14: goto bc150;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 0 5 */
	bc6: {
		int i1 = ASEA_FRAME_VAR(0).as_asINT32;
		int i2 = 5;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JP 129 */
	bc8: {
		if( regs->valueRegister.as_asINT64 > 0 ) {
			l_bc += 131;
			goto bc139;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: CMPIi 0 0 */
	bc10: {
		int i1 = ASEA_FRAME_VAR(0).as_asINT32;
		int i2 = 0;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JS 125 */
	bc12: {
		if( regs->valueRegister.as_asINT64 < 0 ) {
			l_bc += 127;
			goto bc139;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: SUBIi 1 0 0 */
	bc14: {
		asINT32 lhs = ASEA_FRAME_VAR(0).as_asINT32;
		ASEA_FRAME_VAR(1).as_asINT32 = lhs - (0);
		l_bc += 3;
	}
	/* bytecode: JMPP 1 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP 10 */
	bc18: {
		l_bc += 12;
		goto bc30;
	}
	/* bytecode: JMP 27 */
	bc20: {
		l_bc += 29;
		goto bc49;
	}
	/* bytecode: JMP 44 */
	bc22: {
		l_bc += 46;
		goto bc68;
	}
	/* bytecode: JMP 56 */
	bc24: {
		l_bc += 58;
		goto bc82;
	}
	/* bytecode: JMP 73 */
	bc26: {
		l_bc += 75;
		goto bc101;
	}
	/* bytecode: JMP 90 */
	bc28: {
		l_bc += 92;
		goto bc120;
	}
	/* bytecode: JitEntry 2 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238881192 */
	bc36: {
		extern void* asea_strobj0_asea_jit116_module_scripts_2F_switch_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_scripts_2F_switch_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 104 */
	bc47: {
		l_bc += 106;
		goto bc153;
	}
	/* bytecode: JitEntry 4 */
	bc49: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238882632 */
	bc55: {
		extern void* asea_strobj1_asea_jit116_module_scripts_2F_switch_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit116_module_scripts_2F_switch_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc60: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 85 */
	bc66: {
		l_bc += 87;
		goto bc153;
	}
	/* bytecode: JitEntry 6 */
	bc68: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc71: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238884168 */
	bc74: {
		extern void* asea_strobj2_asea_jit116_module_scripts_2F_switch_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj2_asea_jit116_module_scripts_2F_switch_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc77: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc79: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc82: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc85: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238885224 */
	bc88: {
		extern void* asea_strobj3_asea_jit116_module_scripts_2F_switch_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj3_asea_jit116_module_scripts_2F_switch_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc91: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc96: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 52 */
	bc99: {
		l_bc += 54;
		goto bc153;
	}
	/* bytecode: JitEntry 9 */
	bc101: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc104: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238886760 */
	bc107: {
		extern void* asea_strobj4_asea_jit116_module_scripts_2F_switch_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj4_asea_jit116_module_scripts_2F_switch_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc112: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 33 */
	bc118: {
		l_bc += 35;
		goto bc153;
	}
	/* bytecode: JitEntry 11 */
	bc120: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc123: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238888872 */
	bc126: {
		extern void* asea_strobj5_asea_jit116_module_scripts_2F_switch_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj5_asea_jit116_module_scripts_2F_switch_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc129: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc131: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc134: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JMP 14 */
	bc137: {
		l_bc += 16;
		goto bc153;
	}
	/* bytecode: JitEntry 13 */
	bc139: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc142: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238890984 */
	bc145: {
		extern void* asea_strobj6_asea_jit116_module_scripts_2F_switch_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj6_asea_jit116_module_scripts_2F_switch_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc148: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc150: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 1 */
	bc156: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	case 3: goto bc19;
	case 4: goto bc25;
	case 5: goto bc31;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string() */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 9 0 */
	bc12: {
		ASEA_FRAME_VAR(9).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: PshV4 9 */
	bc14: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(9).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 17 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 8 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 8 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 17 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc30;
	case 5: goto bc36;
	case 6: goto bc42;
	case 7: goto bc48;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 0 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)0;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237175848 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc22: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: NOT 2 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc51: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc19;
	case 4: goto bc30;
	case 5: goto bc36;
	case 6: goto bc42;
	case 7: goto bc48;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 2 1 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730237301416 */
	bc13: {
		extern void* asea_strobj0_asea_jit116_module_build;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit116_module_build;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc22: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: NOT 2 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshV4 2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		++l_bc;
	}
	/* bytecode: PSF 18 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PSF 10 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAdd # string string::opAdd(bool) const */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc34: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc39: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 18 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc48: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc51: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc54: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 1 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV2 2 65534 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)65534;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: ADDi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV2 2 20 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: SUBi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs - rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV2 2 65531 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)65531;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: MULi 2 2 4 */
	bc23: {
		asINT32 lhs = ASEA_FRAME_VAR(2).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(4).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs * rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV2 2 65534 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)65534;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: DIVi 2 2 4 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc14;
	case 3: goto bc30;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 7 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)7;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: SetV2 2 4 */
	bc10: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)4;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 3 2 */
	bc12: {
		ASEA_FRAME_VAR(3).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc14: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc17: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 2 */
	bc19: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: CpyVtoV4 4 3 */
	bc20: {
		ASEA_FRAME_VAR(4).as_asDWORD = ASEA_FRAME_VAR(3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: swTOi 4 */
	bc22: {
		ASEA_FRAME_VAR(4).as_asINT32 = ASEA_FRAME_VAR(4).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: MODi 2 2 4 */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 6 2 */
	bc25: {
		ASEA_FRAME_VAR(6).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 6 */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(6).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc22;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc13: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: INCi16 */
	bc14: {
		++ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: RDR2 2 */
	bc15: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 2 */
	bc16: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 4 2 */
	bc17: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc22;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 2 10 */
	bc6: {
		ASEA_FRAME_VAR(2).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: CpyVtoV4 1 2 */
	bc8: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc13: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: DECi16 */
	bc14: {
		--ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: RDR2 2 */
	bc15: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 2 */
	bc16: {
		ASEA_FRAME_VAR(2).as_asINT32 = ASEA_FRAME_VAR(2).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 4 2 */
	bc17: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/enums.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/enums.as:13:1: void main() */
void asea_jit116_module_scripts_2F_enums_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc18;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 11 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)11;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc11: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 4 2 */
	bc13: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc16;
	case 4: goto bc32;
	case 5: goto bc41;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 5 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)5;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CMPIi 1 7 */
	bc11: {
		int i1 = ASEA_FRAME_VAR(1).as_asINT32;
		int i2 = 7;
		if( i1 == i2 )     regs->valueRegister.as_asINT64 = 0;
		else if( i1 < i2 ) regs->valueRegister.as_asINT64 = -1;
		else               regs->valueRegister.as_asINT64 = 1;
		l_bc += 2;
	}
	/* bytecode: JZ 26 */
	bc13: {
		if( regs->valueRegister.as_asINT64 == 0 ) {
			l_bc += 28;
			goto bc41;
		} else {
			l_bc += 2;
		}
	}
	/* bytecode: SUSPEND */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* SUSPEND is not implemented yet */
	}
	/* bytecode: JitEntry 3 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc25: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 4 2 */
	bc27: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc29: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc32: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc35: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: IncVi 1 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JMP -30 */
	bc39: {
		l_bc += -28;
		goto bc11;
	}
	/* bytecode: JitEntry 5 */
	bc41: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc44: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/userclasses.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:64:1: void test() */
void asea_jit116_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:69:1: void method_test() */
void asea_jit117_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 2 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:75:1: void method_field_test() */
void asea_jit118_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc18;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:81:1: void return_field_test() */
void asea_jit119_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc25;
	case 6: goto bc31;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 2 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 132 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:99:1: void pass_by_value_test() */
void asea_jit122_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CHKREF */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL Foo # Foo@ Foo(const Foo&inout other) */
	bc17: {
		extern char asea_script_fn129;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn129);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 4 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 4 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)4;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL take_by_value # void take_by_value(Foo foo) */
	bc25: {
		extern char asea_script_fn121;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn121);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:20:5: void Foo::use_field() */
void asea_jit126_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc28;
	case 5: goto bc36;
	case 6: goto bc44;
	case 7: goto bc52;
	case 8: goto bc61;
	case 9: goto bc69;
	case 10: goto bc77;
	case 11: goto bc85;
	case 12: goto bc97;
	case 13: goto bc112;
	case 14: goto bc127;
	case 15: goto bc141;
	case 16: goto bc153;
	case 17: goto bc168;
	case 18: goto bc183;
	case 19: goto bc198;
	case 20: goto bc213;
	case 21: goto bc225;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 20 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 30 */
	bc14: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)30;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 11259763572604928 */
	bc22: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)50;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 70 */
	bc31: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)70;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 60 */
	bc39: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)60;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 80 */
	bc47: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)80;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 15763363199975424 */
	bc55: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)100;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 90 */
	bc64: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)90;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc69: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 40 */
	bc72: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)40;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 10 */
	bc80: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc84: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc85: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc90: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc91: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc92: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc94: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc95: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc97: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc100: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc103: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc105: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc106: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc107: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc112: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc120: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc121: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc122: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc124: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc125: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc127: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc130: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc133: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc135: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 3 1 */
	bc136: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc138: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc139: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc141: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc144: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc147: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc149: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc150: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc151: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc156: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc161: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc162: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc163: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc165: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc166: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc168: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc171: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc174: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc176: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc177: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc178: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc180: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc181: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc191: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc192: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc193: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc195: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc196: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc198: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc201: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc204: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc206: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc207: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc208: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc210: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc211: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc213: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc216: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc219: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc221: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc222: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc225: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc228: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc231: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo@ Foo(const Foo&inout other) */
void asea_jit129_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761035289856 128 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo::Foo(const Foo&inout other) */
void asea_jit128_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	case 4: goto bc33;
	case 5: goto bc43;
	case 6: goto bc53;
	case 7: goto bc63;
	case 8: goto bc73;
	case 9: goto bc83;
	case 10: goto bc93;
	case 11: goto bc103;
	case 12: goto bc117;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 33 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 34 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc39: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc49: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 48 134217742 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc59: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 50 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc69: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 52 134217742 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc79: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc83: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 54 134217742 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc89: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc90: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 56 134217742 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc99: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc103: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc106: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761035277056 20 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc117: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc120: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:87:1: void handle_test() */
void asea_jit120_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc28;
	case 5: goto bc40;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 6 32074 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: PopPtr */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: PshVPtr 6 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(6).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 4 1689129033170250 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: FREE 6 32074 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc31: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 4 */
	bc37: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 4 563229126327626 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo@ Foo() */
void asea_jit124_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761035289856 123 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:94:1: void take_by_value(Foo foo) */
void asea_jit121_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 562992903126346 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:12:5: void Foo::foo(int a, int b, int c) */
void asea_jit125_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc26;
	case 4: goto bc39;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -2 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc10: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -3 */
	bc19: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc21: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -4 */
	bc32: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-4).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc34: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc36: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 5 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo::Foo() */
void asea_jit123_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761035277056 19 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238152168 */
	bc19: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:45:5: string Foo::return_string_field() */
void asea_jit127_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730238093224 */
	bc6: {
		extern void* asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/userclasses.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo@ Foo(const Foo&inout other) */
void asea_jit129_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761037787776 128 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:64:1: void test() */
void asea_jit116_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:69:1: void method_test() */
void asea_jit117_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 2 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:45:5: string Foo::return_string_field() */
void asea_jit127_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244318536 */
	bc6: {
		extern void* asea_strobj0_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:94:1: void take_by_value(Foo foo) */
void asea_jit121_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 562992903126346 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:87:1: void handle_test() */
void asea_jit120_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc28;
	case 5: goto bc40;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 6 32074 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: PopPtr */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: PshVPtr 6 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(6).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 4 1689129033170250 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: FREE 6 32074 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc31: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 4 */
	bc37: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 4 563229126327626 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:99:1: void pass_by_value_test() */
void asea_jit122_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CHKREF */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL Foo # Foo@ Foo(const Foo&inout other) */
	bc17: {
		extern char asea_script_fn129;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn129);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 4 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 4 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)4;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL take_by_value # void take_by_value(Foo foo) */
	bc25: {
		extern char asea_script_fn121;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn121);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo::Foo() */
void asea_jit123_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761037787136 19 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730244281576 */
	bc19: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo@ Foo() */
void asea_jit124_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761037787776 123 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:75:1: void method_field_test() */
void asea_jit118_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc18;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:81:1: void return_field_test() */
void asea_jit119_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc25;
	case 6: goto bc31;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 2 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 132 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:12:5: void Foo::foo(int a, int b, int c) */
void asea_jit125_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc26;
	case 4: goto bc39;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -2 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc10: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -3 */
	bc19: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc21: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -4 */
	bc32: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-4).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc34: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc36: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 5 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo::Foo(const Foo&inout other) */
void asea_jit128_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	case 4: goto bc33;
	case 5: goto bc43;
	case 6: goto bc53;
	case 7: goto bc63;
	case 8: goto bc73;
	case 9: goto bc83;
	case 10: goto bc93;
	case 11: goto bc103;
	case 12: goto bc117;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 33 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 34 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc39: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc49: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 48 134217742 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc59: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 50 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc69: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 52 134217742 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc79: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc83: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 54 134217742 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc89: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc90: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 56 134217742 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc99: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc103: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc106: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761037787136 20 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc117: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc120: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:20:5: void Foo::use_field() */
void asea_jit126_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc28;
	case 5: goto bc36;
	case 6: goto bc44;
	case 7: goto bc52;
	case 8: goto bc61;
	case 9: goto bc69;
	case 10: goto bc77;
	case 11: goto bc85;
	case 12: goto bc97;
	case 13: goto bc112;
	case 14: goto bc127;
	case 15: goto bc141;
	case 16: goto bc153;
	case 17: goto bc168;
	case 18: goto bc183;
	case 19: goto bc198;
	case 20: goto bc213;
	case 21: goto bc225;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 20 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 30 */
	bc14: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)30;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 11259763572604928 */
	bc22: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)50;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 70 */
	bc31: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)70;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 60 */
	bc39: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)60;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 80 */
	bc47: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)80;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 15763363199975424 */
	bc55: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)100;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 90 */
	bc64: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)90;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc69: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 40 */
	bc72: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)40;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 10 */
	bc80: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc84: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc85: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc90: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc91: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc92: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc94: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc95: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc97: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc100: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc103: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc105: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc106: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc107: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc112: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc120: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc121: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc122: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc124: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc125: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc127: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc130: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc133: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc135: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 3 1 */
	bc136: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc138: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc139: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc141: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc144: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc147: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc149: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc150: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc151: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc156: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc161: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc162: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc163: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc165: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc166: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc168: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc171: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc174: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc176: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc177: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc178: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc180: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc181: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc191: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc192: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc193: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc195: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc196: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc198: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc201: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc204: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc206: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc207: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc208: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc210: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc211: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc213: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc216: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc219: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc221: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc222: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc225: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc228: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc231: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/userclasses.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo@ Foo(const Foo&inout other) */
void asea_jit129_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761040640256 128 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:64:1: void test() */
void asea_jit116_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:69:1: void method_test() */
void asea_jit117_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 2 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:87:1: void handle_test() */
void asea_jit120_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc28;
	case 5: goto bc40;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 6 32074 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: PopPtr */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: PshVPtr 6 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(6).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 4 1689129033170250 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: FREE 6 32074 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc31: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 4 */
	bc37: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 4 563229126327626 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:75:1: void method_field_test() */
void asea_jit118_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc18;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:81:1: void return_field_test() */
void asea_jit119_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc25;
	case 6: goto bc31;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 2 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 132 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:94:1: void take_by_value(Foo foo) */
void asea_jit121_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 562992903126346 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo::Foo(const Foo&inout other) */
void asea_jit128_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	case 4: goto bc33;
	case 5: goto bc43;
	case 6: goto bc53;
	case 7: goto bc63;
	case 8: goto bc73;
	case 9: goto bc83;
	case 10: goto bc93;
	case 11: goto bc103;
	case 12: goto bc117;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 33 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 34 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc39: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc49: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 48 134217742 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc59: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 50 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc69: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 52 134217742 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc79: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc83: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 54 134217742 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc89: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc90: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 56 134217742 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc99: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc103: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc106: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761040654976 20 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc117: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc120: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:99:1: void pass_by_value_test() */
void asea_jit122_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CHKREF */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL Foo # Foo@ Foo(const Foo&inout other) */
	bc17: {
		extern char asea_script_fn129;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn129);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 4 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 4 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)4;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL take_by_value # void take_by_value(Foo foo) */
	bc25: {
		extern char asea_script_fn121;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn121);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo::Foo() */
void asea_jit123_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761040654976 19 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242632104 */
	bc19: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo@ Foo() */
void asea_jit124_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761040640256 123 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:12:5: void Foo::foo(int a, int b, int c) */
void asea_jit125_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc26;
	case 4: goto bc39;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -2 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc10: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -3 */
	bc19: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc21: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -4 */
	bc32: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-4).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc34: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc36: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 5 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:20:5: void Foo::use_field() */
void asea_jit126_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc28;
	case 5: goto bc36;
	case 6: goto bc44;
	case 7: goto bc52;
	case 8: goto bc61;
	case 9: goto bc69;
	case 10: goto bc77;
	case 11: goto bc85;
	case 12: goto bc97;
	case 13: goto bc112;
	case 14: goto bc127;
	case 15: goto bc141;
	case 16: goto bc153;
	case 17: goto bc168;
	case 18: goto bc183;
	case 19: goto bc198;
	case 20: goto bc213;
	case 21: goto bc225;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 20 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 30 */
	bc14: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)30;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 11259763572604928 */
	bc22: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)50;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 70 */
	bc31: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)70;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 60 */
	bc39: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)60;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 80 */
	bc47: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)80;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 15763363199975424 */
	bc55: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)100;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 90 */
	bc64: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)90;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc69: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 40 */
	bc72: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)40;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 10 */
	bc80: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc84: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc85: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc90: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc91: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc92: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc94: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc95: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc97: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc100: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc103: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc105: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc106: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc107: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc112: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc120: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc121: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc122: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc124: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc125: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc127: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc130: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc133: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc135: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 3 1 */
	bc136: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc138: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc139: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc141: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc144: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc147: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc149: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc150: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc151: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc156: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc161: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc162: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc163: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc165: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc166: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc168: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc171: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc174: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc176: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc177: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc178: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc180: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc181: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc191: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc192: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc193: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc195: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc196: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc198: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc201: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc204: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc206: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc207: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc208: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc210: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc211: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc213: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc216: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc219: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc221: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc222: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc225: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc228: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc231: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:45:5: string Foo::return_string_field() */
void asea_jit127_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730242559048 */
	bc6: {
		extern void* asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/userclasses.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo@ Foo(const Foo&inout other) */
void asea_jit129_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761042013696 128 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:64:1: void test() */
void asea_jit116_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:69:1: void method_test() */
void asea_jit117_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 2 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:99:1: void pass_by_value_test() */
void asea_jit122_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CHKREF */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL Foo # Foo@ Foo(const Foo&inout other) */
	bc17: {
		extern char asea_script_fn129;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn129);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 4 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 4 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)4;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL take_by_value # void take_by_value(Foo foo) */
	bc25: {
		extern char asea_script_fn121;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn121);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:75:1: void method_field_test() */
void asea_jit118_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc18;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:81:1: void return_field_test() */
void asea_jit119_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc25;
	case 6: goto bc31;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 2 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 132 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo::Foo() */
void asea_jit123_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042000896 19 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730241002792 */
	bc19: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo@ Foo() */
void asea_jit124_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042013696 123 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:87:1: void handle_test() */
void asea_jit120_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc28;
	case 5: goto bc40;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 6 32074 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: PopPtr */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: PshVPtr 6 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(6).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 4 1689129033170250 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: FREE 6 32074 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc31: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 4 */
	bc37: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 4 563229126327626 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:94:1: void take_by_value(Foo foo) */
void asea_jit121_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 562992903126346 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:12:5: void Foo::foo(int a, int b, int c) */
void asea_jit125_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc26;
	case 4: goto bc39;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -2 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc10: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -3 */
	bc19: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc21: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -4 */
	bc32: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-4).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc34: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc36: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 5 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:20:5: void Foo::use_field() */
void asea_jit126_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc28;
	case 5: goto bc36;
	case 6: goto bc44;
	case 7: goto bc52;
	case 8: goto bc61;
	case 9: goto bc69;
	case 10: goto bc77;
	case 11: goto bc85;
	case 12: goto bc97;
	case 13: goto bc112;
	case 14: goto bc127;
	case 15: goto bc141;
	case 16: goto bc153;
	case 17: goto bc168;
	case 18: goto bc183;
	case 19: goto bc198;
	case 20: goto bc213;
	case 21: goto bc225;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 20 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 30 */
	bc14: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)30;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 11259763572604928 */
	bc22: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)50;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 70 */
	bc31: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)70;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 60 */
	bc39: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)60;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 80 */
	bc47: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)80;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 15763363199975424 */
	bc55: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)100;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 90 */
	bc64: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)90;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc69: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 40 */
	bc72: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)40;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 10 */
	bc80: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc84: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc85: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc90: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc91: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc92: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc94: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc95: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc97: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc100: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc103: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc105: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc106: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc107: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc112: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc120: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc121: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc122: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc124: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc125: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc127: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc130: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc133: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc135: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 3 1 */
	bc136: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc138: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc139: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc141: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc144: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc147: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc149: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc150: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc151: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc156: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc161: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc162: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc163: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc165: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc166: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc168: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc171: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc174: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc176: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc177: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc178: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc180: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc181: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc191: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc192: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc193: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc195: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc196: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc198: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc201: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc204: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc206: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc207: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc208: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc210: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc211: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc213: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc216: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc219: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc221: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc222: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc225: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc228: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc231: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:45:5: string Foo::return_string_field() */
void asea_jit127_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730241043784 */
	bc6: {
		extern void* asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo::Foo(const Foo&inout other) */
void asea_jit128_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	case 4: goto bc33;
	case 5: goto bc43;
	case 6: goto bc53;
	case 7: goto bc63;
	case 8: goto bc73;
	case 9: goto bc83;
	case 10: goto bc93;
	case 11: goto bc103;
	case 12: goto bc117;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 33 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 34 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc39: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc49: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 48 134217742 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc59: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 50 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc69: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 52 134217742 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc79: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc83: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 54 134217742 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc89: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc90: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 56 134217742 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc99: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc103: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc106: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042000896 20 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc117: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc120: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/userclasses.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo@ Foo(const Foo&inout other) */
void asea_jit129_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761041598336 128 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:64:1: void test() */
void asea_jit116_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:87:1: void handle_test() */
void asea_jit120_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc28;
	case 5: goto bc40;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 6 32074 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: PopPtr */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: PshVPtr 6 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(6).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 4 1689129033170250 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: FREE 6 32074 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc31: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 4 */
	bc37: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 4 563229126327626 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:69:1: void method_test() */
void asea_jit117_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 2 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:81:1: void return_field_test() */
void asea_jit119_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc25;
	case 6: goto bc31;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 2 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 132 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:94:1: void take_by_value(Foo foo) */
void asea_jit121_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 562992903126346 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo::Foo(const Foo&inout other) */
void asea_jit128_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	case 4: goto bc33;
	case 5: goto bc43;
	case 6: goto bc53;
	case 7: goto bc63;
	case 8: goto bc73;
	case 9: goto bc83;
	case 10: goto bc93;
	case 11: goto bc103;
	case 12: goto bc117;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 33 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 34 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc39: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc49: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 48 134217742 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc59: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 50 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc69: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 52 134217742 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc79: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc83: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 54 134217742 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc89: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc90: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 56 134217742 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc99: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc103: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc106: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042713856 20 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc117: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc120: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:99:1: void pass_by_value_test() */
void asea_jit122_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CHKREF */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL Foo # Foo@ Foo(const Foo&inout other) */
	bc17: {
		extern char asea_script_fn129;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn129);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 4 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 4 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)4;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL take_by_value # void take_by_value(Foo foo) */
	bc25: {
		extern char asea_script_fn121;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn121);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo::Foo() */
void asea_jit123_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761042713856 19 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232220040 */
	bc19: {
		extern void* asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:20:5: void Foo::use_field() */
void asea_jit126_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc28;
	case 5: goto bc36;
	case 6: goto bc44;
	case 7: goto bc52;
	case 8: goto bc61;
	case 9: goto bc69;
	case 10: goto bc77;
	case 11: goto bc85;
	case 12: goto bc97;
	case 13: goto bc112;
	case 14: goto bc127;
	case 15: goto bc141;
	case 16: goto bc153;
	case 17: goto bc168;
	case 18: goto bc183;
	case 19: goto bc198;
	case 20: goto bc213;
	case 21: goto bc225;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 20 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 30 */
	bc14: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)30;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 11259763572604928 */
	bc22: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)50;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 70 */
	bc31: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)70;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 60 */
	bc39: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)60;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 80 */
	bc47: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)80;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 15763363199975424 */
	bc55: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)100;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 90 */
	bc64: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)90;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc69: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 40 */
	bc72: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)40;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 10 */
	bc80: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc84: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc85: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc90: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc91: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc92: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc94: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc95: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc97: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc100: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc103: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc105: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc106: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc107: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc112: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc120: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc121: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc122: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc124: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc125: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc127: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc130: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc133: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc135: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 3 1 */
	bc136: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc138: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc139: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc141: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc144: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc147: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc149: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc150: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc151: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc156: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc161: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc162: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc163: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc165: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc166: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc168: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc171: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc174: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc176: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc177: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc178: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc180: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc181: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc191: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc192: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc193: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc195: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc196: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc198: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc201: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc204: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc206: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc207: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc208: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc210: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc211: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc213: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc216: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc219: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc221: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc222: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc225: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc228: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc231: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:75:1: void method_field_test() */
void asea_jit118_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc18;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo@ Foo() */
void asea_jit124_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761041598336 123 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:12:5: void Foo::foo(int a, int b, int c) */
void asea_jit125_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc26;
	case 4: goto bc39;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -2 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc10: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -3 */
	bc19: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc21: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -4 */
	bc32: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-4).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc34: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc36: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 5 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:45:5: string Foo::return_string_field() */
void asea_jit127_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730232257000 */
	bc6: {
		extern void* asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: scripts/userclasses.as */ 
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo@ Foo(const Foo&inout other) */
void asea_jit129_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 0 */
	bc4: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ALLOC 137761043134336 128 */
	bc5: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:64:1: void test() */
void asea_jit116_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:69:1: void method_test() */
void asea_jit117_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 2 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:75:1: void method_field_test() */
void asea_jit118_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc18;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc21: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:81:1: void return_field_test() */
void asea_jit119_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc25;
	case 6: goto bc31;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr 2 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 132 */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc23: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc25: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 10 */
	bc28: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS $beh2 # string::~string() */
	bc29: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc31: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc34: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:87:1: void handle_test() */
void asea_jit120_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc28;
	case 5: goto bc40;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 6 32074 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: PopPtr */
	bc19: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: PshVPtr 6 */
	bc20: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(6).as_asPWORD;
		++l_bc;
	}
	/* bytecode: RefCpyV 4 1689129033170250 */
	bc21: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* can't handle release/addref for RefCpyV calls yet */
	}
	/* bytecode: FREE 6 32074 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PopPtr */
	bc27: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, AS_PTR_SIZE);
		l_bc++;
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshC4 789 */
	bc31: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 789;
		l_bc += 2;
	}
	/* bytecode: PshC4 456 */
	bc33: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 456;
		l_bc += 2;
	}
	/* bytecode: PshC4 123 */
	bc35: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -1);
		ASEA_STACK_TOP.as_asDWORD = 123;
		l_bc += 2;
	}
	/* bytecode: PshVPtr 4 */
	bc37: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(4).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 130 */
	bc38: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc40: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 4 563229126327626 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: FREE 2 42949705034 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:94:1: void take_by_value(Foo foo) */
void asea_jit121_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc9;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLINTF 131 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc9: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 0 562992903126346 */
	bc15: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 2 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:20:5: void Foo::use_field() */
void asea_jit126_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc11;
	case 3: goto bc19;
	case 4: goto bc28;
	case 5: goto bc36;
	case 6: goto bc44;
	case 7: goto bc52;
	case 8: goto bc61;
	case 9: goto bc69;
	case 10: goto bc77;
	case 11: goto bc85;
	case 12: goto bc97;
	case 13: goto bc112;
	case 14: goto bc127;
	case 15: goto bc141;
	case 16: goto bc153;
	case 17: goto bc168;
	case 18: goto bc183;
	case 19: goto bc198;
	case 20: goto bc213;
	case 21: goto bc225;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 20 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc8: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc11: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 30 */
	bc14: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)30;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 11259763572604928 */
	bc22: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)50;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc27: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 70 */
	bc31: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)70;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc35: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc36: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 60 */
	bc39: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)60;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc41: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc43: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc44: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV2 1 80 */
	bc47: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)80;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc49: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc51: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc52: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV8 3 15763363199975424 */
	bc55: {
		ASEA_FRAME_VAR(3).as_asQWORD = (asQWORD)100;
		l_bc += 3;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc58: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc61: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 90 */
	bc64: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)90;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc68: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc69: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 40 */
	bc72: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)40;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc74: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc77: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV1 1 10 */
	bc80: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc84: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc85: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc88: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc90: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc91: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc92: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc94: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc95: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc97: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc100: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc103: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc105: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc106: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc107: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 13 */
	bc112: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc115: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc118: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc120: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc121: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc122: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc124: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc125: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 14 */
	bc127: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc130: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc133: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc135: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 3 1 */
	bc136: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc138: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc139: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 15 */
	bc141: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc144: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc147: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc149: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc150: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc151: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 16 */
	bc153: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc156: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc159: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc161: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc162: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc163: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc165: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc166: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 17 */
	bc168: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc171: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc174: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc176: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc177: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc178: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc180: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc181: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 18 */
	bc183: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc186: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc189: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc191: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: swTOi 1 */
	bc192: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT16;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc193: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc195: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc196: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 19 */
	bc198: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc201: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc204: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc206: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: sbTOi 1 */
	bc207: {
		ASEA_FRAME_VAR(1).as_asINT32 = ASEA_FRAME_VAR(1).as_asINT8;
		l_bc += 1;
	}
	/* bytecode: iTOi64 3 1 */
	bc208: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc210: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc211: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 20 */
	bc213: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc216: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc219: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc221: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: PshV8 3 */
	bc222: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc223: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 21 */
	bc225: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc228: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc231: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:45:5: string Foo::return_string_field() */
void asea_jit127_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc15;
	case 3: goto bc28;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239508744 */
	bc6: {
		extern void* asea_strobj0_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj0_asea_jit127_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc9: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALLSYS opAssign # string& string::opAssign(const string&in) */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc15: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc18: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc21: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc25: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS $beh0 # string::string(const string&in) */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc28: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 4 */
	bc31: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo::Foo() */
void asea_jit123_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc24;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc6: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc7: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761043127936 19 */
	bc9: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PGA 136730239655528 */
	bc19: {
		extern void* asea_strobj1_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)&asea_strobj1_asea_jit123_module_scripts_2F_userclasses_2E_as;
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALLSYS print # void print(const string&in) */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc24: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:99:1: void pass_by_value_test() */
void asea_jit122_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc12;
	case 4: goto bc19;
	case 5: goto bc27;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CALL Foo # Foo@ Foo() */
	bc6: {
		extern char asea_script_fn124;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn124);
		return;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc12: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 2 */
	bc15: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: CHKREF */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL Foo # Foo@ Foo(const Foo&inout other) */
	bc17: {
		extern char asea_script_fn129;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn129);
		return;
	}
	/* bytecode: JitEntry 4 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: STOREOBJ 4 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: VAR 4 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = (asPWORD)4;
		l_bc++;
	}
	/* bytecode: GETOBJ 0 */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: CALL take_by_value # void take_by_value(Foo foo) */
	bc25: {
		extern char asea_script_fn121;
		l_bc += 2;
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		asea_call_script_function(regs, (asCScriptFunction*)&asea_script_fn121);
		return;
	}
	/* bytecode: JitEntry 5 */
	bc27: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc30: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: FREE 2 42949705034 */
	bc33: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:6:5: Foo@ Foo() */
void asea_jit124_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PSF 2 */
	bc3: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761043134336 123 */
	bc4: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LOADOBJ 2 */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RET 0 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:12:5: void Foo::foo(int a, int b, int c) */
void asea_jit125_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc26;
	case 4: goto bc39;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -2 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-2).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc10: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc11: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc16: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -3 */
	bc19: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-3).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc21: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc23: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc24: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc26: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc29: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 1 -4 */
	bc32: {
		ASEA_FRAME_VAR(1).as_asDWORD = ASEA_FRAME_VAR(-4).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: iTOi64 3 1 */
	bc34: {
		ASEA_FRAME_VAR(3).as_asINT64 = ASEA_FRAME_VAR(1).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 3 */
	bc36: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(3).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc37: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc39: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc42: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 5 */
	bc45: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* /home/sdelang/projects/src/cpp/angelsea/tests/scripts/userclasses.as:0:0: Foo::Foo(const Foo&inout other) */
void asea_jit128_module_scripts_2F_userclasses_2E_as(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc13;
	case 3: goto bc23;
	case 4: goto bc33;
	case 5: goto bc43;
	case 6: goto bc53;
	case 7: goto bc63;
	case 8: goto bc73;
	case 9: goto bc83;
	case 10: goto bc93;
	case 11: goto bc103;
	case 12: goto bc117;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 32 134217742 */
	bc6: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc9: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 32 134217742 */
	bc10: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc12: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 2 */
	bc13: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 33 134217742 */
	bc16: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc19: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 33 134217742 */
	bc20: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc22: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 34 134217742 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc29: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 34 134217742 */
	bc30: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc32: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 4 */
	bc33: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 36 134217742 */
	bc36: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR4 1 */
	bc39: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 36 134217742 */
	bc40: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV4 1 */
	bc42: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 5 */
	bc43: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 40 134217742 */
	bc46: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc49: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 40 134217742 */
	bc50: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc52: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 6 */
	bc53: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 48 134217742 */
	bc56: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc59: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 48 134217742 */
	bc60: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc62: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 7 */
	bc63: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 50 134217742 */
	bc66: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc69: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 50 134217742 */
	bc70: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc72: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 8 */
	bc73: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 52 134217742 */
	bc76: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR2 1 */
	bc79: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asWORD = ASEA_VALUEREG_DEREF().as_asWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 52 134217742 */
	bc80: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV2 1 */
	bc82: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 9 */
	bc83: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 54 134217742 */
	bc86: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR1 1 */
	bc89: {
		asea_var* var = &ASEA_FRAME_VAR(1);
		var->as_asDWORD = 0;
		var->as_asBYTE = ASEA_VALUEREG_DEREF().as_asBYTE;
		l_bc++;
	}
	/* bytecode: LoadThisR 54 134217742 */
	bc90: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV1 1 */
	bc92: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 10 */
	bc93: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LoadRObjR -2 56 134217742 */
	bc96: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDR8 3 */
	bc99: {
		asea_var* var = &ASEA_FRAME_VAR(3);
		var->as_asQWORD = ASEA_VALUEREG_DEREF().as_asQWORD;
		l_bc++;
	}
	/* bytecode: LoadThisR 56 134217742 */
	bc100: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: WRTV8 3 */
	bc102: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 11 */
	bc103: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: PshVPtr 0 */
	bc106: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(0).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc107: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: PshVPtr -2 */
	bc109: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -AS_PTR_SIZE);
		ASEA_STACK_TOP.as_asPWORD = ASEA_FRAME_VAR(-2).as_asPWORD;
		++l_bc;
	}
	/* bytecode: ADDSi 64 134217742 */
	bc110: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: RDSPtr */
	bc112: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: ALLOC 137761043127936 20 */
	bc113: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 12 */
	bc117: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 2 */
	bc120: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 1 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)1;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 -2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)4294967294;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: ADDi 2 1 3 */
	bc13: {
		asINT32 lhs = ASEA_FRAME_VAR(1).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(3).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs + rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 20 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)20;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SUBi 2 1 3 */
	bc13: {
		asINT32 lhs = ASEA_FRAME_VAR(1).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(3).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs - rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 -5 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)4294967291;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MULi 2 1 3 */
	bc13: {
		asINT32 lhs = ASEA_FRAME_VAR(1).as_asINT32;
		asINT32 rhs = ASEA_FRAME_VAR(3).as_asINT32;
		ASEA_FRAME_VAR(2).as_asINT32 = lhs * rhs;
		l_bc += 2;
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 -2 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)4294967294;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: DIVi 2 1 3 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc10;
	case 3: goto bc20;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 7 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)7;
		l_bc += 2;
	}
	/* bytecode: SetV4 3 4 */
	bc8: {
		ASEA_FRAME_VAR(3).as_asDWORD = (asDWORD)4;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc10: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: MODi 2 1 3 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 5 2 */
	bc15: {
		ASEA_FRAME_VAR(5).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 5 */
	bc17: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(5).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc18: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc20: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc23: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc26: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc19;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: CpyVtoV4 2 1 */
	bc11: {
		ASEA_FRAME_VAR(2).as_asDWORD = ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc += 2;
	}
	/* bytecode: NEGi 2 */
	bc13: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: iTOi64 4 2 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc19;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc11: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: INCi */
	bc12: {
		++ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: RDR4 2 */
	bc13: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 4 2 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
/* start of angelsea static header */

/*
    This generated source file contains macro definitions and references to
    internal structures extracted from the AngelScript scripting library, which
    are licensed under the zlib license (license provided below).

    Very minor modifications may have been applied to formatting or to allow
    compilation via a C compiler.

    This file should NOT be compiled by a C++ compiler, as it relies on type
    punning thru unions in a way that is not legal in C++.

    Generated function definitions are the result of stitching of code stencils
    which are closely based on the definition and internal structure of the
    AngelScript virtual machine.
    Checks and references to variables may be elided at compile time when
    possible.
*/

/*
   AngelCode Scripting Library
   Copyright (c) 2003-2025 Andreas Jonsson

   This software is provided 'as-is', without any express or implied
   warranty. In no event will the authors be held liable for any
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any
   purpose, including commercial applications, and to alter it and
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you
      must not claim that you wrote the original software. If you use
      this software in a product, an acknowledgment in the product
      documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas Jonsson
   andreas@angelcode.com
*/

/*
    Definitions normally provided by <angelscript.h>, but that in case of JIT we
    override them with definitions provided by c2mir.
*/
#ifdef ANGELSEA_SUPPORT

typedef __INT8_TYPE__    asINT8;
typedef __INT16_TYPE__   asINT16;
typedef __INT32_TYPE__   asINT32;
typedef __INT64_TYPE__   asINT64;
typedef __UINT8_TYPE__   asBYTE;
typedef __UINT16_TYPE__  asWORD;
typedef __UINT32_TYPE__  asUINT;
typedef __UINT32_TYPE__  asDWORD;
typedef __UINT64_TYPE__  asQWORD;
typedef __UINTPTR_TYPE__ asPWORD;

#define asASSERT

/* TODO: is this ever used in the VM other than AS_PTR_SIZE? */
#if __SIZEOF_POINTER__ == 4
	#define asBCTYPE_PTR_ARG    asBCTYPE_DW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_DW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_DW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_DW_ARG
	#define AS_PTR_SIZE 1
#else
	#define asBCTYPE_PTR_ARG    asBCTYPE_QW_ARG
	#define asBCTYPE_PTR_DW_ARG asBCTYPE_QW_DW_ARG
	#define asBCTYPE_wW_PTR_ARG asBCTYPE_wW_QW_ARG
	#define asBCTYPE_rW_PTR_ARG asBCTYPE_rW_QW_ARG
	#define AS_PTR_SIZE 2
#endif

#define VALUE_OF_BOOLEAN_TRUE 1

typedef enum
{
	asEXECUTION_FINISHED        = 0,
	asEXECUTION_SUSPENDED       = 1,
	asEXECUTION_ABORTED         = 2,
	asEXECUTION_EXCEPTION       = 3,
	asEXECUTION_PREPARED        = 4,
	asEXECUTION_UNINITIALIZED   = 5,
	asEXECUTION_ACTIVE          = 6,
	asEXECUTION_ERROR           = 7,
	asEXECUTION_DESERIALIZATION = 8
} asEContextState;

/*
	Union to provide safe type punning with various AngelScript variables (as
	far as C aliasing rules allow, but not C++'s)
	This is only _fully_ legal and could theoretically break if the compiler can
	see beyond its compile unit (e.g. with LTO) but it should be otherwise
	unproblematic (and AS itself does worse, anyway).
*/
typedef union {
	asINT8 as_asINT8;
	asINT16 as_asINT16;
	asINT32 as_asINT32;
	asINT64 as_asINT64;
	asBYTE as_asBYTE;
	asWORD as_asWORD;
	asDWORD as_asDWORD;
	asQWORD as_asQWORD;
	asPWORD as_asPWORD;
	float as_float;
	double as_double;
	void* as_ptr;
} asea_var;

typedef struct asSVMRegisters asSVMRegisters;
typedef struct asIScriptContext asIScriptContext;
typedef struct asITypeInfo asITypeInfo;
typedef struct asCScriptFunction asCScriptFunction;
typedef struct asCObjectType asCObjectType;
typedef struct asSTypeBehaviour asSTypeBehaviour;

/* Layout exactly mimics asSVMRegisters */
typedef struct
{
	/*
		We rewrite some of the asDWORD* pointers to be void* instead; this is
		across the compile boundary in the case of JIT.
	*/
	asDWORD          *programPointer;     /* points to current bytecode instruction */
	void             *stackFramePointer;  /* function stack frame */
	void             *stackPointer;       /* top of stack (grows downward) */
	asea_var          valueRegister;      /* temp register for primitives */
	void             *objectRegister;     /* temp register for objects and handles */
	asITypeInfo      *objectType;         /* type of object held in object register */
	/* HACK: doProcessSuspend is normally defined as bool in C++; assume int equivalent */
	int              doProcessSuspend;    /* whether or not the JIT should break out when it encounters a suspend instruction */
	asIScriptContext *ctx;                /* the active context */
} asea_vm_registers;

#endif

/*
    The following definitions are part of the angelsea runtime.hpp
*/

void asea_call_script_function(void* vm_registers, void* function);
void asea_debug_message(asSVMRegisters* vm_registers, const char* text);

/*
    The following definitions are additional angelsea helpers
*/

#define ASEA_STACK_DWORD_OFFSET(base, dword_offset) (void*)((char*)(base) + ((dword_offset) * 4))
#define ASEA_FRAME_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_fp, -(dword_offset))))
#define ASEA_STACK_VAR(dword_offset) (*(asea_var*)(ASEA_STACK_DWORD_OFFSET(l_sp, (dword_offset))))
#define ASEA_STACK_TOP (*(asea_var*)(l_sp))
#define ASEA_VALUEREG_DEREF() (*(asea_var*)(regs->valueRegister.as_ptr))

/* end of angelsea static header */

/* start of code generated by angelsea bytecode2c */

/* MODULE: build */ 
/* str:1:1: void main() */
void asea_jit116_module_build(asSVMRegisters *_regs, asPWORD entryLabel) {
	asea_vm_registers *regs = (asea_vm_registers *)_regs;
	asDWORD *l_bc;
	void *l_sp;
	void *l_fp;
		l_bc = regs->programPointer;
		l_sp = regs->stackPointer;
		l_fp = regs->stackFramePointer;
	switch(entryLabel) {
	default:
	case 1: goto bc0;
	case 2: goto bc8;
	case 3: goto bc19;
	}

	/* bytecode: JitEntry 1 */
	bc0: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc3: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: SetV4 1 10 */
	bc6: {
		ASEA_FRAME_VAR(1).as_asDWORD = (asDWORD)10;
		l_bc += 2;
	}
	/* bytecode: JitEntry 2 */
	bc8: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: LDV 1 */
	bc11: {
		regs->valueRegister.as_asPWORD = (asPWORD)&ASEA_FRAME_VAR(1).as_asDWORD;
		l_bc++;
	}
	/* bytecode: DECi */
	bc12: {
		--ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: RDR4 2 */
	bc13: {
		asea_var* var = &ASEA_FRAME_VAR(2);
		var->as_asDWORD = ASEA_VALUEREG_DEREF().as_asDWORD;
		l_bc++;
	}
	/* bytecode: iTOi64 4 2 */
	bc14: {
		ASEA_FRAME_VAR(4).as_asINT64 = ASEA_FRAME_VAR(2).as_asINT32;
		l_bc += 2;
	}
	/* bytecode: PshV8 4 */
	bc16: {
		l_sp = ASEA_STACK_DWORD_OFFSET(l_sp, -2);
		ASEA_STACK_TOP.as_asQWORD = ASEA_FRAME_VAR(4).as_asQWORD;
		++l_bc;
	}
	/* bytecode: CALLSYS print # void print(int64) */
	bc17: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
	/* bytecode: JitEntry 3 */
	bc19: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: JitEntry 0 */
	bc22: {
		l_bc += 1+AS_PTR_SIZE;
	}
	/* bytecode: RET 0 */
	bc25: {
		regs->programPointer = l_bc;
		regs->stackPointer = l_sp;
		regs->stackFramePointer = l_fp;
		return; /* unsupported instruction */
	}
}
===============================================================================
All tests passed (247 assertions in 42 test cases)

